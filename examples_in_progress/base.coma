use int.Int
use int.ComputerDivision
use list.List
use list.SortedInt
use list.Permut
use list.Reverse
use list.Append

-------------------------------------------------------------------------------

let halt [] = (? any)
let fail [] = { false } halt

let if {b: bool} (then) (else) =
    any [ then -> {b} (! then)
        | else -> {not b} (! else) ]

let ok [] =
    f1
    [ f1     = f2 (g)
    | f2 (g) = g
    | f3 (g) = f1 [ f1 -> halt] ]
    [ g -> h ]
    [ h -> any ]

let unList {l: list int} (onCons [] {h: int} {t: list int}) (onNil []) =
    any
    [ oncons [] {h: int} {t: list int} -> { l = Cons h t } (! onCons {h} {t})
    | onnil  []                        -> { l =  Nil } (! onNil) ]

let assign_int (&r : int) {v: int} (out [r]) =
    any [ ret [r] -> { r = v } (! out) ]

let assign_list (&r : list int) {v: list int} (out [r]) =
    any [ ret [r] -> { r = v } (! out) ]

-------------------------------------------------------------------------------

let product {a b: int} (return {c: int}) =
    { b >= 0 }
    (! loop
       [ loop [p q r] =
         { q >= 0 }{ p*q+r = a*b }
         (! if {q > 0} (next) (last)
            [ last -> return {r}
            | next ->
              (if {mod q 2 = 1} (write_r) (write_p)
               [ write_r       -> write_p [&r <- {r + p}] ]
               [ write_p [r]   -> write_q [&p <- {p + p}] ]
               [ write_q [p r] -> loop    [&q <- {div q 2}]])])
       ]
       [ &p: int = {a}
       | &q: int = {b}
       | &r: int = {0} ]
    )
    [ return {c: int} -> { c = a * b } (! return {c}) ]

let test (&x &y &z: int) =
  (! if {x = 0} (out_x) (out_x [&x <- {0}])
     [ out_x [x] ->
       if {y = 0} (out_y) (out_y [&y <- {0}])
       [ out_y [y] ->
          if {z = 0} (out_z) (out_z [&z <- {0}])
          [ out_z [z] -> { x = y = z = 0 } halt]]])

let insert {x: int} {l: list int} (return {o: list int}) =
    { sorted l }
    (! unList {l}
             (fun {h: int} {t: list int} ->
                if {x < h}
                   (-> break {Cons x l})
                   (-> insert {x} {t} (fun {r: list int} -> break {Cons h r})))
             (-> break {Cons x Nil}))
    [ break {r: list int} -> { sorted r && permut r (Cons x l) } (! return {r})]

let postIncr (&r: int) =
    (fun {v: int} ->
        (! break [&r <- {r+1}])
        [ break [r] -> { r = v+1 } (! return {v}) ]) {r}
    [ return [r] {p: int} -> any]

let postIncrLet (&r: int) =
    (! break [&r <- {r+1}])
    [ break [r] -> { r = v+1 } (! return {v}) ]
    [ v: int = {r} ]
    [ return [r] {p: int} -> any]

let rev_append [] {l0 r0: list int} =
  loop
  [ loop = { reverse l ++ r = reverse l0 ++ r0 }
      (! unList {l}
           (fun {h: int} {t: list int} -> loop [ &r <- {Cons h r} | &l <- {t} ])
           -- (fun {h: int} {t: list int} -> assign_list &r {Cons h r} (fun -> assign_list &l {t} (loop)))
           (out))]
  [ out -> { r = reverse l0 ++ r0 } (? halt) ]
  [ &r: list int = {r0}
  | &l: list int = {l0}]
