module A

       use list.List
       use int.Int
       use ref.Ref
       use mach.int.UInt32
       use list.Length
       use mach.int.Int32


       exception Error

       let f1 (x:int32) =
           x-1

       let rec g1 (x:int32)
       variant { x }
       =
           if x < 1 then 1 else (g1 (f1 x) * (2:int32))

(*
       type t = { a: int32; b : int32 }


       let f () =
           { a = 0; b = 1}

       let g [@ evm:external] ()
              =
        (f ()).b
*)

       use mach.evm.Gas

        let rec length4 [@ evm:gas_checking] (l:list 'a) : int32
         requires { (length l) <= max_int32 }
         ensures { !gas - old !gas <= (length l) * 128 + 71 }
         ensures { !alloc - old !alloc <= 0 }
         ensures { result = length l }
         variant { l } =
          match l with
          | Nil -> add_gas 71 0; 0
          | Cons _ l -> add_gas 128 0; 1 + length4 l
          end

        let rec mk4 [@ evm:gas_checking] (i:int32) : list int32
          requires { 0 <= i }
          ensures { !gas - old !gas <= i * 185 + 113 }
          ensures { !alloc - old !alloc <= i * 96 + 32 }
          ensures { i = length result }
          variant { i } =
          if i <= 0 then (add_gas 113 32; Nil) else
          let l = mk4 (i-1) in
          add_gas 185 96;
          Cons (0x42:int32) l


       let g4 [@ evm:gas_checking] (i:int32) : int32
          requires { 0 <= i }
          ensures { !gas - old !gas <= i * 313 + 242 }
          ensures { !alloc - old !alloc <= i * 96 + 32 }
       =
        add_gas 58 0;
        let l = mk4 i in
        length4 l

       let g4' [@ evm:gas_checking] () : int32
           (* raises { Error -> true } *)
       =
         label H in
         add_gas 78 0;
         let gas1 = get_remaining_gas () in
         let r1 = g4 4 in
         let gas2 = get_remaining_gas () in
         assert { !gas - (!gas at H) <= 4 * 313 + 242 };
         assert { !alloc - (!alloc at H) <= 4 * 96 + 32 };
         assert { actual_gas_used (!gas - (!gas at H)) (!alloc - (!alloc at H)) <= 1494 };
         (* evm doesn't have the same cost function *)
         (* if not (UInt256.(gas1 - gas2 <= 1494)) then raise Error; *)
         add_gas 24 0;
         r1

       type mut = { mutable v: int32 }

       let g5 i =
         let r = { v = 0 } in
         r.v <- i;
         r.v

       let m6 = { v = 0 }

       let g6 i : int32 =
         let j = m6.v in
         m6.v <- i;
         j

       let g7 [@ evm:gas_checking] (x:int32) : int32 =
           add_gas 66 0;
           if x <= 0 then 0 else 2

       let g8 [@ evm:gas_checking] (x:int32) : int32 =
           if x <= 0 then (add_gas 56 0; 0) else (add_gas 66 0; 2)

       let g9 [@ evm:gas_checking] (x:int32) : int32 =
           add_gas 109 1;
           let r = ref x in
           r := !r - (1:int32);
           !r

       use mach.evm.ArrayUInt32

       let g10 [@ evm:gas_checking] (n:uint32) (x:uint32) : uint32
           ensures { !alloc = old !alloc + n }
       =
           add_gas 159 0;
           let r = make n in
           r[0] <- x;
           r[n-1] <- x+1;
           r[0] + r[n-1] - 1

       let g [@ evm:external] () : bool
           raises { Error -> true }
       =
        (* test 1 *)
        let () =
         let r1 = g1 4 in
         let o1 : int32 = (0x10:int32) in
         if not (r1 = o1) then raise Error
        in
        (* test 4 *)
        let () =
         label H in
         let r1 = g4' () in
         let o1 : int32 = (4:int32) in
         if not (r1 = o1) then raise Error
        in
        (* test 5 *)
        let () =
         let r1 = g5 (0x4444) in
         let o1 : int32 = (0x4444:int32) in
         if not (r1 = o1) then raise Error
        in
        (* test 6 *)
        m6.v <- 0;
        let () =
         let r1 = g6 4 in
         let r2 = g6 5 in
         let o1 : int32 = (4:int32) in
         if not (r1 = 0) then raise Error;
         if not (r2 = o1) then raise Error
        in
        (* test 7 *)
        let () =
         let r1 = g7 (0x4) in
         let o1 : int32 = (0x2:int32) in
         if not (r1 = o1) then raise Error
        in
        (* test 8 *)
        let () =
         let r1 = g8 (0x4) in
         let o1 : int32 = (0x2:int32) in
         if not (r1 = o1) then raise Error
        in
        (* test 9 *)
        let () =
         let r1 = g9 (0x4) in
         let o1 : int32 = (0x3:int32) in
         if not (r1 = o1) then raise Error
        in
        (* test 10 *)
        let () =
         let r1 = g10 (0x10) (0x4) in
         let o1 : uint32 = (0x8:uint32) in
         if not (r1 = o1) then raise Error
        in
        false

end
