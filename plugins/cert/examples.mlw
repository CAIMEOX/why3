
use int.Int


(* premier exemple introductif *)

let incr (ref x : int) : unit
  requires Pre { x < 100 }
  writes   { x }
  ensures  Post { x <= 100 }
  = x <- x+1

(*

goal incr'vc :
  forall x:int. x < 100 -> (forall x1:int. x1 = (x + 1) -> x1 <= 100)

traduction monadique :

let incr_monad (x:int) (Pre: x < 100) : { x1:int | Post : x1 <= 100 } =
  let x1 = x+1 in
  { x1 | incr'vc x Pre x1 <preuve de x1 = x+1> }

il faudra mieux une syntaxe Coq ou Dedukti bien sur.

ici, sans meme avoir de terme-preuve pour incr'vc, mais en supposant
son existence, on peut tenter de type-checker la definition de
incr_monad pour certifier que le calcul de la formule de incr'vc etait
correct.

*)



(* deuxieme exemple, avex risque d'alias *)

let incr2 (ref x : int) (ref y : int) : unit
  requires { x < 100 /\  y < 200 }
  writes   { x, y }
  ensures  { x <= 100 /\ y <= 200 }
  = x <- x+1; y <- y+1

(*

le risque potentiel d'alias est illustré par

*)
(*
let wrong (ref z : int) = incr2 z z
*)
(*
qui est refusé par Why3 :

File "../exemples.mlw", line 49, characters 26-31: This application creates an illegal alias


goal incr2'vc :
  forall x:int, y:int.
   x < 100 /\ y < 200 ->
   (forall x1:int.
     x1 = (x + 1) -> (forall y1:int. y1 = (y + 1) -> x1 <= 100 /\ y1 <= 200))

La traduction fonctionnelle monadique de incr2 doit etre grosso-modo :

let incr2_monad (x:int) (y:int) (Pre:  x < 100 /\  y < 200 ) :
   { x1:int, y1:int | Post : x <= 100 /\ y <= 200 }
   =
   let x1 = x + 1 in
   let y1 = y + 1 in
   { x1,y1 | incr2'vc .... }

*)



(* if !i > 1 then s := 0 else () *)

(* traduction monadique : *)
(* \ x0 . if x0.i > 1 *)
(*        then ({s = 0}, ()) *)
(*        else ({}, ()) *)

let rw_example i s =
    let ref i = i + 1 in
    let ref s = s + 1 in
    if !i > 0
    then s := 0;
    !s

(* traduction monadique : *)
(* les variables, les constantes et le déreferencement ne renvoient pas la mise à jour vide des
   variables écrites ? *)
(* x0 après les variables de la fonction ? *)
(* \ i s : int. \ x0. *)
(*       let x1, v = *)
(*       	  let x2, v = *)
(* 	      let x3, _ = trad (rw_example) (x0 + { i = i + 1, s = s + 1 }) in *)
(* 	      let v = (x2+x3).s in *)
(* 	      (x3, v) *)
(* 	  in *)
(* 	  ({}, v) *)
(*       in *)
(*       ({}, v) *)
