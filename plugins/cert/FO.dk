Term : Type.
Prop : Type.
def prf  : Prop -> Type.

true : Prop.
false: Prop.

not : Prop -> Prop.
and : Prop -> Prop -> Prop.
or  : Prop -> Prop -> Prop.
imp : Prop -> Prop -> Prop.

forall: (Term -> Prop) -> Prop.
exists: (Term -> Prop) -> Prop.

equals: Term -> Term -> Prop.

def equiv: Prop -> Prop -> Prop := A: Prop => B: Prop => and (imp A B) (imp B A).

tt: prf true.
[]  prf false --> P: Prop -> prf P
[A] prf (not A) --> prf A -> prf false
[A,B] prf (and A B)   --> P: Prop -> (prf A -> prf B -> prf P) -> prf P
[A,B] prf (or  A B)   --> P: Prop -> (prf A -> prf P) -> (prf B -> prf P) -> prf P
[A,B] prf (imp A B)   --> prf A -> prf B
[A]  prf (forall A)  --> x: Term -> prf (A x)
[A]  prf (exists A)  --> P: Prop -> (x: Term -> prf (A x) -> prf P) -> prf P
[x,y] prf (equals x y) --> P: (Term -> Prop) -> prf (P x) -> prf (P y).


(; Define sequents. The sequent <A, B ⊢ C, D> is represented by < A → B → ¬C → ¬ D → ⊥ > ;)

def empty : Prop
:= false.

def hyp : Prop -> Prop -> Prop
:= A => s => imp A s.

def goal : Prop -> Prop -> Prop
:= A => s => imp (not A) s.

(; classical axiom and reasoning about negation ;)

def iff : A : Prop -> B : Prop -> Prop
:= A => B => and (imp A B) (imp B A).

def nni (A  : Prop) :
    prf A -> prf (not (not A))
:= a => na => na a.

def contra (A : Prop) (B : Prop) :
    (prf A -> prf B) ->
    prf (not B) -> prf (not A)
:= p => nb => a => nb (p a).

tnd : A : Prop -> prf (or A (not A)).

def nne : A : Prop -> prf (not (not A)) -> prf A
:= A : Prop => nna =>
   tnd A A (a => a) (na => nna na A).


(; *** Theorems ;)

(; implication ;)
def imp_elim  : A: Prop -> B: Prop -> prf (imp A B) -> prf A -> prf B
:= A: Prop => B: Prop => p: prf (imp A B) => p.

def imp_intro : A: Prop -> B: Prop -> (prf A -> prf B) -> prf (imp A B)
:= A: Prop => B: Prop => p: (prf A -> prf B) => p.

(; disjunction ;)
def or_intro_1 : A: Prop -> B: Prop -> prf A -> prf (or A B)
:= A: Prop => B: Prop => p: prf A =>
        P: Prop => f: (prf A -> prf P) => g: (prf B -> prf P) => f p.

def or_intro_2 : A: Prop -> B: Prop -> prf B -> prf (or A B)
:= A: Prop => B: Prop => p: prf B =>
        P: Prop => f: (prf A -> prf P) => g: (prf B -> prf P) => g p.

def or_elim : A: Prop -> B: Prop -> prf (or A B) -> C: Prop -> prf (imp A C) -> prf (imp B C)  -> prf C
:= A: Prop => B: Prop => p: prf (or A B) => p.

(; conjunction ;)
def and_intro  : A: Prop -> B: Prop -> prf A -> prf B -> prf (and A B)
:= A: Prop => B: Prop => a: prf A => b: prf B => P: Prop => f: (prf A -> prf B -> prf P) => f a b.

def and_elim_1 : A: Prop -> B: Prop -> prf (and A B) -> prf A
:= A: Prop => B: Prop => p: prf (and A B) => p A (a: prf A => b: prf B => a).

def and_elim_2 : A: Prop -> B: Prop -> prf (and A B) -> prf B
:= A: Prop => B: Prop => p: prf (and A B) => p B (a: prf A => b: prf B => b).

(; Universal quantifier ;)
def forall_intro: P: (Term->Prop) -> (t: Term -> prf (P t)) -> prf (forall P)
:= P: (Term->Prop) => p: (t: Term -> prf (P t)) => p.

def forall_elim: P: (Term->Prop) -> t: Term -> p: prf (forall P) -> prf (P t)
:= P: (Term->Prop) => t: Term => p: prf (forall P) => p t.

(; Existential quantifier ;)
def exists_intro: P: (Term->Prop) -> t: Term -> prf (P t) -> prf (exists P)
:= P: (Term -> Prop) => t: Term => p: prf (P t) =>
        A: Prop => f: (x: Term -> prf (P x) -> prf A) => f t p.

def exists_elim: P: (Term->Prop) -> Q: Prop -> prf (exists P) -> prf (forall (x => imp (P x) Q)) -> prf Q
:= P: (Term->Prop) => Q: Prop => p1: prf (exists P) => p2: prf (forall (x => imp (P x) Q))
        => p1 Q p2.

(; Equality ;)

def eq_refl: prf (forall (x: Term => equals x x))
:= x: Term => P: (Term -> Prop) => p: prf (P x) => p.

def eq_sym: prf( forall (x: Term => forall (y: Term => (imp (equals x y) (equals y x)))) )
:= x: Term => y: Term => p: prf (equals x y) => p (z: Term => equals z x) (eq_refl x).

def eq_trans: prf ( forall (x: Term => forall (y: Term => (forall (z: Term => imp (and (equals x y) (equals y z)) (equals x z))))) )
:= x: Term => y: Term => z: Term => p: prf (and (equals x y) (equals y z)) => P: (Term -> Prop) => q: prf (P x) =>
        and_elim_2 (equals x y) (equals y z) p P (and_elim_1 (equals x y) (equals y z) p P q).


(; certificate lines ;)

def hole : prf false -> prf false
:= f => f.

def axiom (P : Prop) :
    prf P -> prf (not P) -> prf false
:= p => np => np p.

def trivial_hyp : prf false -> prf false
:= f => f.

def trivial_goal : prf (not true) -> prf false
:= h => h tt.

def cut (A : Prop) :
    prf (goal A empty) ->
    prf (hyp  A empty) ->
    prf false
:= nna => na => nna na.

def split_hyp (A : Prop) (B : Prop) :
    prf (hyp A empty) ->
    prf (hyp B empty) ->
    prf (hyp (or A B) empty)
:= s1 => s2 => h =>
   or_elim A B h false s1 s2.

def split_goal (A : Prop) (B : Prop) :
    prf (goal A empty) ->
    prf (goal B empty) ->
    prf (goal (and A B) empty)
:= nna => nnb => nni (and A B) (and_intro A B (nne A nna) (nne B nnb)).

def unfold_iff_hyp (A : Prop) (B : Prop) :
    prf (hyp (and (imp A B) (imp B A)) empty) ->
    prf (hyp (iff A B) empty)
:= h => h.

def unfold_iff_goal (A : Prop) (B : Prop) :
    prf (goal (and (imp A B) (imp B A)) empty) ->
    prf (goal (iff A B) empty)
:= h => h.

def unfold_arr_hyp (A : Prop) (B : Prop) :
    prf (hyp (or (not A) B) empty) ->
    prf (hyp (imp A B) empty)
:= h => impab =>
   h (tnd A (or (not A) B) (a =>  or_intro_2 (not A) B (impab a))
                           (na => or_intro_1 (not A) B na)).

def unfold_arr_goal (A : Prop) (B : Prop) :
    prf (goal (or (not A) B) empty) ->
    prf (goal (imp A B) empty)
:= h => nni (imp A B) (a =>
   nne (or (not A) B) h B (na => na a B)
                          (b => b)).

def swap_neg_neg_hyp (A : Prop) :
    prf (goal A empty) ->
    prf (hyp (not A) empty)
:= h => h.

def swap_neg_hyp (A : Prop) :
    prf (goal (not A) empty) ->
    prf (hyp A empty)
:= nnna => nne (not A) nnna.

def swap_neg_goal (A : Prop) :
    prf (hyp (not A) empty) ->
    prf (goal A empty)
:= h => h.

def swap_neg_neg_goal (A : Prop) :
    prf (hyp A empty) ->
    prf (goal (not A) empty)
:= na => nni (not A) na.

def destruct_hyp (A : Prop) (B : Prop) :
    prf (hyp A (hyp B empty)) ->
    prf (hyp (and A B) empty)
:= s => h =>
   s (and_elim_1 A B h) (and_elim_2 A B h).

def destruct_goal (A : Prop) (B : Prop) :
    prf (goal A (goal B empty)) ->
    prf (goal (or A B) empty)
:= h => nab => h (a => nab (or_intro_1 A B a))
                 (b => nab (or_intro_2 A B b)).

def dir_left_hyp (A : Prop) (B : Prop) :
    prf (hyp A empty) ->
    prf (hyp (and A B) empty)
:= na => ab => na (and_elim_1 A B ab).

def dir_left_goal (A : Prop) (B : Prop) :
    prf (goal A empty) ->
    prf (goal (or A B) empty)
:= nna => nab => nab (or_intro_1 A B (nne A nna)).

def dir_right_hyp (A : Prop) (B : Prop) :
    prf (hyp B empty) ->
    prf (hyp (and A B) empty)
:= nb => ab => nb (and_elim_2 A B ab).

def dir_right_goal (A : Prop) (B : Prop) :
    prf (goal B empty) ->
    prf (goal (or A B) empty)
:= nnb => nab => nab (or_intro_2 A B (nne B nnb)).

def weakening_hyp (A : Prop) :
    prf empty ->
    prf (hyp A empty)
:= f => a => f.

def weakening_goal (A : Prop) :
    prf empty ->
    prf (goal A empty)
:= f => a => f.


def intro_quant_hyp (P : Term -> Prop) :
    (y : Term -> prf (hyp (P y) empty)) ->
    prf (hyp (exists P) empty)
:= t => ep => exists_elim P false ep (x => px => t x px).


def inst_quant_hyp (P : Term -> Prop) (t : Term) :
    prf (hyp (forall (x => P x)) (hyp (P t) empty)) ->
    prf (hyp (forall (x => P x)) empty)
:= f => h => f h (h t).

(; #CHECK (P => h => t => h t) ;)
(; : ;)
(; (P : Term -> Prop) -> (h : (x : Term -> prf (P x))) -> ;)
(; (t : Term) -> prf (P t). ;)

(; #CHECK (P => h => t => h t) ;)
(; : ;)
(; (P : Term -> Prop) -> (h : prf (forall (x => P x))) ;)
(; (t : Term) -> prf (P t). ;)




