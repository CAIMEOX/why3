open Why3

open Ident
open Term
open Decl
open Task

open Cert_certificates

let decl_cert f = Trans.decl_acc (hole ()) (|>>) (fun d _ -> f d)
let decl_l_cert f = Trans.decl_l_acc (hole ()) (|>>) (fun d _ -> f d)

let map_ty = function
    | None -> Ty.ty_bool
    | Some ty -> ty

(* Identity transformation with a certificate *)
let id_ctrans = Trans.store (fun task -> [task], hole ())

(** Combinators on transformations with a certificate *)

(* Generalize ctrans on <task list * certif>, with the invariant that each
   <Hole> in the certif corresponds to one task in the list *)
let ctrans_gen (ctr : ctrans) (ts, c : task list * visible_cert) =
  let llt, lc = List.split (List.map (Trans.apply ctr) ts) in
  List.flatten llt, c |>>> lc

(* Apply a <ctrans> and then apply another <ctrans> on every <task> generated by
   the first one *)
let compose (tr1 : ctrans) (tr2 : ctrans) : ctrans = Trans.store (fun t ->
  Trans.apply tr1 t |> ctrans_gen tr2)

let compose_list l = List.fold_left compose id_ctrans l

let is_hole (v, c) =
  match v, c with
  | [i], Hole j when id_equal i j -> true
  | _ -> false

(* If Then Else on transformations with a certificate : applies [tri], if the
   task changed then apply [trt] else apply [tre] *)
let ite tri trt tre = Trans.store (fun task ->
  let (lt, c) as tri_task = Trans.apply tri task in
  if not (Lists.equal task_equal lt [task] && is_hole c)
  then ctrans_gen trt tri_task
  else ctrans_gen tre tri_task)

(* Try on transformations with a certificate : try each transformation in <lctr>
   and keep the one that closes the <task> *)
let rec try_close (lctr : ctrans list) : ctrans = Trans.store (fun task ->
  match lctr with
  | [] -> Trans.apply id_ctrans task
  | h::t -> let lctask_h, cert_h = Trans.apply h task in
            if lctask_h = []
            then [], cert_h
            else Trans.apply (try_close t) task)

(* Repeat on a transformation with a certificate : keep applying <ctr> as long
   as the task changes *)
let repeat (ctr : ctrans) : ctrans = Trans.store (fun task ->
  let gen_task = Trans.apply id_ctrans task in
  let gen_tr = ctrans_gen ctr in
  let rec loop gt =
    let new_gt = gen_tr gt in
    if Lists.equal task_equal (fst new_gt) (fst gt)
    then gt
    else loop new_gt in
  loop gen_task)


(** Primitive transformations with a certificate *)

(* First, some utility functions *)
let default_goal task = function
  | Some pr -> pr
  | None -> task_goal task

type target =
  | Pr of prsymbol
  | Everywhere
  | Anywhere
  | Nowhere

let find_target any every where task =
  if any then Anywhere
  else if every then Everywhere
  else Pr (default_goal task where)

let match_tg tg pr = match tg with
  | Pr pr' -> pr_equal pr' pr
  | Everywhere | Anywhere -> true
  | Nowhere -> false

let update_tg_c (tg, c1) co =
  match tg, co with
  | Everywhere, Some c2 -> Everywhere, c1 |>> c2
  | Everywhere, None -> Everywhere, c1
  | _, Some c2 -> assert (is_hole c1); Nowhere, c2
  | _, None -> tg, c1

let revert_cert pr decls =
  lambda one (fun i ->
      let rec rc = function
        | [] -> Hole i
        | h::tail ->
            match h.d_node with
            | Dprop (_, pr_d, _) ->
                Swap (pr_d,
                      Construct (pr_d, pr, pr,
                                 Fold (pr, rc tail)))
            | Dparam ls ->
                let pr' = pr_clone pr in
                llet pr (fun g ->
                    let ix = id_fresh ls.ls_name.id_string in
                    let x = create_vsymbol ix (Opt.get ls.ls_value) in
                    let vx = t_var x in
                    let g = t_replace (t_app_infer ls []) vx g in
                    let closed_t = t_forall_close [x] [] g in
                    Assert (pr', closed_t, Clear (pr, rename pr' pr (rc tail)),
                            InstQuant (pr', pr', vx, Axiom (pr', pr))))
            | _ -> assert false in
      rc decls)

let intro_cert pr decls =
  lambda one (fun i ->
      let rec ic decls = match decls with
        |  [] -> Hole i
        |  {d_node = Dparam _}::_ ->
            let rec intro_decls_var acc = function
              | {d_node = Dparam ls} :: l -> intro_decls_var (ls::acc) l
              | l -> List.rev acc, l in
            let lls, decls = intro_decls_var [] decls in
            List.fold_right (fun ls c -> IntroQuant (pr, ls.ls_name, c))
              lls (ic decls)
        | {d_node = Dprop (_, npr, _)}::decls ->
            Unfold (pr,
                    Destruct(pr, npr, pr,
                             Swap (npr, ic decls)))
        | _ -> assert false in
      ic (List.rev decls)
)
