module RewInt

use int.Int

constant x : int

axiom x_zero : x = -1

goal G1 : x + 1 = 0

end


module RewProp

predicate a
predicate b
predicate c
predicate d
predicate p bool
axiom A : a
axiom B : b

goal rew_goal  : (c <-> a) -> (d \/ c)

goal rew_hyp : (c <-> d) -> c -> d

goal rew_inv_hyp : (d <-> c) -> c -> d

goal rew_prem_hyp : (a -> b -> c <-> d) -> c -> d

goal rew_inv_prem_hyp : (a -> b -> d <-> c) -> c -> d

goal rew_forall_hyp : forall x. (forall u. p u <-> a) -> (p x <-> p x)

end


module RewMonoid

clone algebra.Monoid with axiom .

goal one_inv : forall a b. op a b = op b a -> forall x . op (op x a) b = op (op x b) a

end


module RewGroup

  clone algebra.Monoid with axiom .

  function inv t : t
  axiom Inv_def_l : forall x : t. op (inv x) x = unit

  lemma Inv_both : forall x : t. op (inv x) (op x (inv x)) = inv x

  goal Inv_def_right : forall y. op y (inv y) = unit

end

