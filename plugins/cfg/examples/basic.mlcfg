
module Basic

use int.Int

let cfg cfgassert (x:int) : int
  requires { x >= 10 }
  ensures { result >= x }
  =
  {
  assert { x >= 0 };
  x+1;
  }


let cfg cfggoto (x:int) : int
  requires { x >= 0 }
  ensures { result = x + 2 }
  =
  var y : int;
  {
  y <- x+1;
  goto L
  }
  L {
  y <- y+1;
  y
  }

let cfg cfg_inv (x:int) : int
  requires { x >= 0 }
  ensures { result >= 2 }
  =
  var y:int;
  {
  y <- x;
  invariant I { y >= 0} ;
  y <- y + 1;
  invariant J { y >= 1} ;
  y <- y + 1;
  y
  }


let cfg cfg_infinite_loop (x:int) : int
  requires { x >= 0 }
  ensures { result >= 2 }
  =
  var y:int;
  {
  y <- 0;
  goto L;
  }
  L {
  y <- y + 1;
  invariant I { exists z. y = z+z+1 };
  y <- y + 1;
  goto L;
  }


let cfg cfg_finite_loop (x:int) : int
  requires { x >= 0 }
  ensures { result >= 2 }
  =
  var y:int;
  {
  y <- 0;
  goto L;
  }
  L {
  y <- y + 1;
  invariant I { exists z. y = z+z+1 };
  y <- y + 1;
  switch (y <= x)
  | True -> goto L
  | False -> y
  end
  }

let cfg incr (ref x:int) : int
  ensures { x = old x + 1 }
  =
  {
  x <- x + 1;
  x
  }

let cfg main () : unit =
  var tmp : int;
  var tmp2 : int;
  {
  tmp <- cfgassert 42;
  tmp <- cfggoto 43;
  tmp <- cfg_inv 44;
  tmp <- cfg_infinite_loop 45;
  tmp <- cfg_finite_loop 46;
  tmp2 <- 47;
  tmp <- incr tmp2;
  assert { tmp2 = 48 };
  ()
  }

end