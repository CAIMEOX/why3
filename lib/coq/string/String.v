(* This file is generated by Why3's Coq-realize driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.

(* Why3 goal *)
Definition concat : BuiltIn.string -> BuiltIn.string -> BuiltIn.string.
Proof.
  exact append.
Defined.

(* Why3 goal *)
Lemma concat_assoc :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ((concat (concat s1 s2) s3) = (concat s1 (concat s2 s3))).
Proof.
  intros s1 s2 s3.
  induction s1.
  auto.
  simpl.
  rewrite IHs1.
  auto.
Qed.

(* Why3 goal *)
Definition rliteral : BuiltIn.string.
Proof.
  exact EmptyString.
Defined.

(* Why3 goal *)
Lemma rliteral_axiom : True.
Proof.
  exact I.
Qed.

(* Why3 goal *)
Lemma concat_empty :
  forall (s:BuiltIn.string),
  ((concat s rliteral) = (concat rliteral s)) /\ ((concat rliteral s) = s).
Proof.
  intros s.
  simpl.
  refine (conj _ _).
  - induction s as [| h t IH].
    + simpl. exact (eq_refl rliteral).
    + simpl. rewrite IH. exact (eq_refl _).
  - exact (eq_refl _).
Qed.

Definition length : BuiltIn.string -> Numbers.BinNums.Z.
Proof.
  exact (fun s => Z_of_nat (Strings.String.length s)).
Defined.

(* (* Why3 goal *)
Definition length : BuiltIn.string -> Numbers.BinNums.Z :=
  fix length s := match s with
  | EmptyString => 0%Z
  | String _ s' => (1 + (length s'))%Z
  end.

(* TODO remove? *)
Lemma of_nat_succ_add_1: forall (n:nat), (Z.of_nat (S n)) = (1 + (Z.of_nat n))%Z.
Proof.
  intros n.
  rewrite Nat2Z.inj_succ.
  rewrite Z.add_1_l.
  reflexivity.
Qed. 

Lemma length_coq_eq_length_why3: forall (s: BuiltIn.string), (Z.of_nat (Strings.String.length s) = length s).
Proof.
  intros s.
  induction s as [| x xs IH].
  + auto.
  + simpl String.length.
    rewrite of_nat_succ_add_1.
    rewrite IH.
    simpl length.
    case xs.
    - simpl. reflexivity.
    - auto.
Qed. *)

(* Why3 goal *)
Lemma length_empty : ((length rliteral) = 0%Z).
Proof.
  exact (eq_refl _).
Qed.

(* Why3 goal *)
Lemma length_nonnegative : forall (s:BuiltIn.string), (0%Z <= (length s))%Z.
Proof.
  intros.
  unfold length.
  (* SearchAbout Z.of_nat. *)
  apply Nat2Z.is_nonneg.
Qed.

(* Why3 goal *)
Lemma length_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  ((length (concat s1 s2)) = ((length s1) + (length s2))%Z).
Proof.
  unfold length, concat.
  intros s1 s2.
  induction s1 as [| x xs IH].
  - auto.
  - simpl Strings.String.length.
    repeat rewrite Nat2Z.inj_succ.
    rewrite IH.
    auto with zarith.
Qed.

(* Why3 goal *)
Definition lt : BuiltIn.string -> BuiltIn.string -> Prop.
Proof.

Admitted.

(* Why3 goal *)
Lemma lt_empty :
  forall (s:BuiltIn.string), ~ (s = rliteral) -> lt rliteral s.
Proof.
intros s h1.

Admitted.

(* Why3 goal *)
Lemma lt_not_com :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> ~ lt s2 s1.
Proof.
intros s1 s2 h1.
admit.
Admitted.

(* Why3 goal *)
Lemma lt_ref : forall (s1:BuiltIn.string), ~ lt s1 s1.
Proof.
  intros s1.

Admitted.

(* Why3 goal *)
Lemma lt_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  lt s1 s2 /\ lt s2 s3 -> lt s1 s3.
Proof.
intros s1 s2 s3 (h1,h2).

Admitted.

(* Why3 goal *)
Definition le : BuiltIn.string -> BuiltIn.string -> Prop.
Proof.

Admitted.

(* Why3 goal *)
Lemma le_empty : forall (s:BuiltIn.string), le rliteral s.
Proof.
intros s.
admit.
Admitted.

(* Why3 goal *)
Lemma le_ref : forall (s1:BuiltIn.string), le s1 s1.
Proof.
intros s1.

admit.
Admitted.

(* Why3 goal *)
Lemma lt_le :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), lt s1 s2 -> le s1 s2.
Proof.
intros s1 s2 h1.
admit.
Admitted.

(* Why3 goal *)
Lemma lt_le_eq :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), le s1 s2 ->
  lt s1 s2 \/ (s1 = s2).
Proof.
intros s1 s2 h1.

admit.
Admitted.

(* Why3 goal *)
Lemma le_trans :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  le s1 s2 /\ le s2 s3 -> le s1 s3.
Proof.
intros s1 s2 s3 (h1,h2).

admit.
Admitted.

(* Why3 goal *)
Definition mixfix_lbrb (s: BuiltIn.string) (n: Numbers.BinNums.Z): BuiltIn.string :=
  match n with
  | Z0 => match String.get 0 s with
          | None => EmptyString
          | Some a => String a EmptyString
          end
  | Zpos p => match String.get (nat_of_N (Npos p)) s with
              | None => EmptyString
              | Some a => String a EmptyString
              end
  | Zneg p => EmptyString
  end.

(* TODO Shall we show that mixfix_lbrb and String.get are somewhat equivalent? *)

(* Why3 goal *)
Lemma at_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((mixfix_lbrb s i) = rliteral).
Proof.
  intros s i.
  generalize s.
  destruct i.
  * intros s0 H. destruct H.
    + discriminate H.
    + destruct s0.
      - auto.
      - simpl.
        unfold Z.le in H.
        unfold not in H.
        simpl in H.
        destruct s0 in H.
        --  simpl in H.
            contradiction.
        --  rewrite <- length_coq_eq_length_why3 in H.
            simpl in H.
            contradiction.
  * intros s0.
    intros.
    destruct H.
    + discriminate H.
    + simpl.
      destruct s0.
      - simpl. auto.
      - admit.
  * intros s0.
    intros.
    destruct H.
    + simpl. auto.
    + simpl. auto.


  (*intros s i.
  intros H.
  destruct H.
  + destruct i.
    - simpl.
      discriminate H.
    - discriminate H.
    - simpl. exact (eq_refl _).
  + case s.
    - unfold mixfix_lbrb.
      destruct i.
      * simpl. auto.
      * simpl. auto.
      * auto.
    - intros a s0.
      destruct i.
      ** simpl.
         contradiction.*)

admit.
Admitted.

(* Why3 goal *)
Lemma at_empty :
  forall (i:Numbers.BinNums.Z), ((mixfix_lbrb rliteral i) = rliteral).
Proof.
intros i.

admit.
Admitted.

(* Why3 goal *)
Lemma at_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := mixfix_lbrb s i in
  ((0%Z <= i)%Z /\ (i < (length s))%Z -> ((length j) = 1%Z)) /\
  (~ ((0%Z <= i)%Z /\ (i < (length s))%Z) -> ((length j) = 0%Z)).
Proof.
intros s i j.

admit.
Admitted.

(* Why3 goal *)
Definition substring :
  BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z -> BuiltIn.string.
Proof.

Admitted.

(* Why3 goal *)
Lemma substring_out_of_range :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (i < 0%Z)%Z \/ ((length s) <= i)%Z -> ((substring s i x) = rliteral).
Proof.
intros s i x h1.

admit.
Admitted.

(* Why3 goal *)
Lemma substring_of_length_zero_or_less :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (x <= 0%Z)%Z -> ((substring s i x) = rliteral).
Proof.
intros s i x h1.

admit.
Admitted.

(* Why3 goal *)
Lemma substring_of_empty :
  forall (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((substring rliteral i x) = rliteral).
Proof.
intros i x.

admit.
Admitted.

(* Why3 goal *)
Lemma substring_smaller :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  ((length (substring s i x)) <= (length s))%Z.
Proof.
intros s i x.

admit.
Admitted.

(* Why3 goal *)
Lemma substring_smaller_x :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z < x)%Z -> ((length (substring s i x)) <= x)%Z.
Proof.
intros s i x h1.

admit.
Admitted.

(* Why3 goal *)
Lemma substring_length :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z) (x:Numbers.BinNums.Z),
  (0%Z < x)%Z /\ (0%Z <= i)%Z /\ (i < (length s))%Z ->
  (((length s) < (i + x)%Z)%Z ->
   ((length (substring s i x)) = ((length s) - i)%Z)) /\
  (~ ((length s) < (i + x)%Z)%Z -> ((length (substring s i x)) = x)).
Proof.
intros s i x (h1,(h2,h3)).

admit.
Admitted.

(* Why3 goal *)
Lemma substring_at :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((mixfix_lbrb s i) = (substring s i 1%Z)).
Proof.
intros s i.

admit.
Admitted.

(* Why3 goal *)
Definition prefixof : BuiltIn.string -> BuiltIn.string -> Prop.
Proof.

Admitted.

(* Why3 goal *)
Lemma prefixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  prefixof s1 s2 <-> (s1 = (substring s2 0%Z (length s1))).
Proof.
intros s1 s2.

admit.
Admitted.

(* Why3 goal *)
Lemma prefixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 (concat s1 s2).
Proof.
intros s1 s2.

admit.
Admitted.

(* Why3 goal *)
Lemma prefixof_empty : forall (s2:BuiltIn.string), prefixof rliteral s2.
Proof.
intros s2.

admit.
Admitted.

(* Why3 goal *)
Lemma prefixof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ prefixof s1 rliteral.
Proof.
intros s1 h1.

admit.
Admitted.

(* Why3 goal *)
Definition suffixof : BuiltIn.string -> BuiltIn.string -> Prop.
Proof.

Admitted.

(* Why3 goal *)
Lemma suffixof_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  suffixof s1 s2 <->
  (s1 = (substring s2 ((length s2) - (length s1))%Z (length s1))).
Proof.
intros s1 s2.

admit.
Admitted.

(* Why3 goal *)
Lemma suffixof_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s2 (concat s1 s2).
Proof.
intros s1 s2.

admit.
Admitted.

(* Why3 goal *)
Lemma suffixof_empty : forall (s2:BuiltIn.string), suffixof rliteral s2.
Proof.
intros s2.

admit.
Admitted.

(* Why3 goal *)
Lemma suffiof_empty2 :
  forall (s1:BuiltIn.string), ~ (s1 = rliteral) -> ~ suffixof s1 rliteral.
Proof.
intros s1 h1.

admit.
Admitted.

(* Why3 goal *)
Definition contains : BuiltIn.string -> BuiltIn.string -> Prop.
Proof.

Admitted.

(* Why3 goal *)
Lemma contains_prefixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), prefixof s1 s2 ->
  contains s2 s1.
Proof.
intros s1 s2 h1.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_suffixof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string), suffixof s1 s2 ->
  contains s2 s1.
Proof.
intros s1 s2 h1.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_empty :
  forall (s2:BuiltIn.string), contains rliteral s2 <-> (s2 = rliteral).
Proof.
intros s2.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_empty2 : forall (s1:BuiltIn.string), contains s1 rliteral.
Proof.
intros s1.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((substring s1 i (length s2)) = s2) -> contains s1 s2.
Proof.
intros s1 s2 i h1.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_concat :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  contains (concat s1 s2) s1 /\ contains (concat s1 s2) s2.
Proof.
intros s1 s2.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_at :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((mixfix_lbrb s1 i) = s2) -> contains s1 s2.
Proof.
intros s1 s2 i h1.

admit.
Admitted.

(* Why3 goal *)
Definition indexof :
  BuiltIn.string -> BuiltIn.string -> Numbers.BinNums.Z -> Numbers.BinNums.Z.
Proof.

Admitted.

(* Why3 goal *)
Lemma indexof_empty :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i <= (length s))%Z -> ((indexof s rliteral i) = i).
Proof.
intros s i (h1,h2).

admit.
Admitted.

(* Why3 goal *)
Lemma indexof_empty1 :
  forall (s:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof rliteral s i in
  (j = (-1%Z)%Z) \/ (s = rliteral) /\ (i = j) /\ (j = 0%Z).
Proof.
intros s i j.

admit.
Admitted.

(* Why3 goal *)
Lemma indexof_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  contains s1 s2 ->
  ((0%Z <= j)%Z /\ (j <= (length s1))%Z) /\
  ((substring s1 j (length s2)) = s2).
Proof.
intros s1 s2 j h1.

admit.
Admitted.

(* Why3 goal *)
Lemma contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  (0%Z <= (indexof s1 s2 i))%Z -> contains s1 s2.
Proof.
intros s1 s2 i h1.

admit.
Admitted.

(* Why3 goal *)
Lemma not_contains_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ~ contains s1 s2 -> ((indexof s1 s2 i) = (-1%Z)%Z).
Proof.
intros s1 s2 i h1.

admit.
Admitted.

(* Why3 goal *)
Lemma substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= j)%Z -> ((substring s1 j (length s2)) = s2).
Proof.
intros s1 s2 i j h1.

admit.
Admitted.

(* Why3 goal *)
Lemma indexof_out_of_range :
  forall (i:Numbers.BinNums.Z) (s1:BuiltIn.string) (s2:BuiltIn.string),
  ~ ((0%Z <= i)%Z /\ (i <= (length s1))%Z) -> ((indexof s1 s2 i) = (-1%Z)%Z).
Proof.
intros i s1 s2 h1.

admit.
Admitted.

(* Why3 goal *)
Lemma indexof_in_range :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  let j := indexof s1 s2 i in
  (0%Z <= i)%Z /\ (i <= (length s1))%Z ->
  (j = (-1%Z)%Z) \/ (i <= j)%Z /\ (j <= (length s1))%Z.
Proof.
intros s1 s2 i j (h1,h2).

admit.
Admitted.

(* Why3 goal *)
Lemma indexof_contains_substring :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z /\ (i <= (length s1))%Z) /\
  contains (substring s1 i ((length s1) - i)%Z) s2 ->
  (i <= (indexof s1 s2 i))%Z /\ ((indexof s1 s2 i) <= (length s1))%Z.
Proof.
intros s1 s2 i ((h1,h2),h3).

admit.
Admitted.

(* Why3 goal *)
Definition replace :
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.
Proof.

Admitted.

(* Why3 goal *)
Lemma replace_empty :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replace s1 rliteral s3) = (concat s3 s1)).
Proof.
intros s1 s3.

admit.
Admitted.

(* Why3 goal *)
Lemma replace_not_contains :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replace s1 s2 s3) = s1).
Proof.
intros s1 s2 s3 h1.

admit.
Admitted.

(* Why3 goal *)
Lemma replace_empty2 :
  forall (s2:BuiltIn.string) (s3:BuiltIn.string),
  let s4 := replace rliteral s2 s3 in
  ((s2 = rliteral) -> (s4 = s3)) /\ (~ (s2 = rliteral) -> (s4 = rliteral)).
Proof.
intros s2 s3 s4.

admit.
Admitted.

(* Why3 goal *)
Lemma replace_substring_indexof :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  let j := indexof s1 s2 0%Z in
  ((j < 0%Z)%Z -> ((replace s1 s2 s3) = s1)) /\
  (~ (j < 0%Z)%Z ->
   ((replace s1 s2 s3) =
    (concat (concat (substring s1 0%Z j) s3)
     (substring s1 (j + (length s2))%Z (((length s1) - j)%Z - (length s2))%Z)))).
Proof.
intros s1 s2 s3 j.

admit.
Admitted.

(* Why3 goal *)
Definition replaceall :
  BuiltIn.string -> BuiltIn.string -> BuiltIn.string -> BuiltIn.string.
Proof.

Admitted.

(* Why3 goal *)
Lemma replaceall_empty1 :
  forall (s1:BuiltIn.string) (s3:BuiltIn.string),
  ((replaceall s1 rliteral s3) = s1).
Proof.
intros s1 s3.

admit.
Admitted.

(* Why3 goal *)
Lemma not_contains_replaceall :
  forall (s1:BuiltIn.string) (s2:BuiltIn.string) (s3:BuiltIn.string),
  ~ contains s1 s2 -> ((replaceall s1 s2 s3) = s1).
Proof.
intros s1 s2 s3 h1.

admit.
Admitted.

(* Why3 goal *)
Definition to_int : BuiltIn.string -> Numbers.BinNums.Z.
Proof.

admit.
Admitted.

(* Why3 goal *)
Lemma to_int_gt_minus_1 :
  forall (s:BuiltIn.string), ((-1%Z)%Z <= (to_int s))%Z.
Proof.
intros s.

admit.
Admitted.

(* Why3 goal *)
Lemma to_int_empty : ((to_int rliteral) = (-1%Z)%Z).
Proof.


admit.
Admitted.

(* Why3 assumption *)
Definition is_digit (s:BuiltIn.string) : Prop :=
  (0%Z <= (to_int s))%Z /\ ((to_int s) <= 9%Z)%Z.

(* Why3 goal *)
Definition from_int : Numbers.BinNums.Z -> BuiltIn.string.
Proof.

Admitted.

(* Why3 goal *)
Lemma from_int_negative :
  forall (i:Numbers.BinNums.Z), (i < 0%Z)%Z <-> ((from_int i) = rliteral).
Proof.
intros i.

admit.
Admitted.

(* Why3 goal *)
Lemma from_int_to_int :
  forall (i:Numbers.BinNums.Z),
  ((0%Z <= i)%Z -> ((to_int (from_int i)) = i)) /\
  (~ (0%Z <= i)%Z -> ((to_int (from_int i)) = (-1%Z)%Z)).
Proof.
intros i.

admit.
Admitted.