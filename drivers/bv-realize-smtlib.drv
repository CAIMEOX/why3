
  (* copied from drivers/cvc4_16.gen

     would be better to *share* these declarations

  *)


prelude "(set-info :smt-lib-version 2.6)"
prelude "(set-logic AUFBVFPDTNIRA)"
(*
    A    : Array
    UF   : Uninterpreted Function
    BV   : BitVectors
    FP   : FloatingPoint
    DT   : Datatypes
    NIRA : NonLinear Integer+Real Arithmetic
*)

import "smt-libv2.gen"
printer "smtv2.6"
(* import "smt-libv2-bv.gen" *)
(* import "cvc4_bv.gen" *)
(* import "smt-libv2-floats.gen" *)
(* import "discrimination.gen" *)

transformation "inline_trivial"
transformation "eliminate_builtin"
transformation "detect_polymorphism"
transformation "eliminate_definition_if_poly"
transformation "eliminate_inductive"
transformation "eliminate_algebraic_if_poly"
transformation "eliminate_literal"
transformation "eliminate_epsilon"
transformation "simplify_formula"

(* Prepare for counter-example query: get rid of some quantifiers
   (makes it possible to query model values of the variables in
   premises) and introduce counter-example projections.  Note: does
   nothing if meta get_counterexmp is not set *)
(* transformation "prepare_for_counterexmp" *)

(* transformation "discriminate_if_poly" *)
(* transformation "encoding_smt_if_poly" *)

(** Error messages specific to CVC4 *)

outofmemory "(error \".*out of memory\")\\|Cannot allocate memory"
timeout "interrupted by timeout"
steps "smt::SmtEngine::resourceUnitsUsed, \\([0-9]+.?[0-9]*\\)" 1
(**
Unfortunately, there is no specific output message when CVC4 reaches its resource limit
steplimitexceeded "??"
*)


(** Extra theories supported by CVC4 *)

(* CVC4 division seems to be the Euclidean one, not the Computer one *)
theory int.EuclideanDivision
  syntax function div "(div %1 %2)"
  syntax function mod "(mod %1 %2)"
  remove prop Mod_bound
  remove prop Div_mod
  remove prop Mod_1
  remove prop Div_1
end


  (* copied from drivers/smtlib2-bv.gen{BVGen,BV8}

     would be better to *share* these declarations

  *)


theory "bv-realize".BV8Realize
  meta "literal:keep" type t

  syntax literal t "#x%2x"
  syntax type t "(_ BitVec 8)"

  syntax function zeros "#x00"
  syntax function one   "#x01"
  syntax function ones  "#xFF"
  syntax function size_bv "(_ bv8 8)"

  syntax predicate is_signed_positive "(bvsge %1 (_ bv0 8))"

  syntax function bw_and "(bvand %1 %2)"
  syntax function bw_or "(bvor %1 %2)"
  syntax function bw_xor "(bvxor %1 %2)"
  syntax function bw_not "(bvnot %1)"

  syntax predicate ult "(bvult %1 %2)"
  syntax predicate ule "(bvule %1 %2)"
  syntax predicate ugt "(bvugt %1 %2)"
  syntax predicate uge "(bvuge %1 %2)"
  syntax predicate slt "(bvslt %1 %2)"
  syntax predicate sle "(bvsle %1 %2)"
  syntax predicate sgt "(bvsgt %1 %2)"
  syntax predicate sge "(bvsge %1 %2)"

  syntax function add "(bvadd %1 %2)"
  syntax function sub "(bvsub %1 %2)"
  syntax function neg "(bvneg %1)"
  syntax function mul "(bvmul %1 %2)"
  syntax function udiv "(bvudiv %1 %2)"
  syntax function urem "(bvurem %1 %2)"

  syntax function lsr_bv "(bvlshr %1 %2)"
  syntax function asr_bv "(bvashr %1 %2)"
  syntax function lsl_bv "(bvshl %1 %2)"

  syntax function rotate_left_bv "(bvor (bvshl %1 (bvurem %2 (_ bv8 8))) (bvlshr %1 (bvsub (_ bv8 8) (bvurem %2 (_ bv8 8)))))"
  syntax function rotate_right_bv "(bvor (bvlshr %1 (bvurem %2 (_ bv8 8))) (bvshl %1 (bvsub (_ bv8 8) (bvurem %2 (_ bv8 8)))))"


end

(*

theory bv.BV64
  meta "literal:keep" type t

  syntax literal t "#x%16x"
  syntax type t "(_ BitVec 64)"

  syntax function zeros "#x0000000000000000"
  syntax function one   "#x0000000000000001"
  syntax function ones  "#xFFFFFFFFFFFFFFFF"
  syntax function size_bv "(_ bv64 64)"

  syntax predicate is_signed_positive "(bvsge %1 (_ bv0 64))"

  syntax function rotate_left_bv "(bvor (bvshl %1 (bvurem %2 (_ bv64 64))) (bvlshr %1 (bvsub (_ bv64 64) (bvurem %2 (_ bv64 64)))))"
  syntax function rotate_right_bv "(bvor (bvlshr %1 (bvurem %2 (_ bv64 64))) (bvshl %1 (bvsub (_ bv64 64) (bvurem %2 (_ bv64 64)))))"
end

theory bv.BV32
  meta "literal:keep" type t

  syntax literal t "#x%8x"
  syntax type t "(_ BitVec 32)"

  syntax function zeros "#x00000000"
  syntax function one   "#x00000001"
  syntax function ones  "#xFFFFFFFF"
  syntax function size_bv "(_ bv32 32)"

  syntax predicate is_signed_positive "(bvsge %1 (_ bv0 32))"

  syntax function rotate_left_bv "(bvor (bvshl %1 (bvurem %2 (_ bv32 32))) (bvlshr %1 (bvsub (_ bv32 32) (bvurem %2 (_ bv32 32)))))"
  syntax function rotate_right_bv "(bvor (bvlshr %1 (bvurem %2 (_ bv32 32))) (bvshl %1 (bvsub (_ bv32 32) (bvurem %2 (_ bv32 32)))))"
end

theory bv.BV16
  meta "literal:keep" type t

  syntax literal t "#x%4x"
  syntax type t "(_ BitVec 16)"

  syntax function zeros "#x0000"
  syntax function one   "#x0001"
  syntax function ones  "#xFFFF"
  syntax function size_bv "(_ bv16 16)"

  syntax predicate is_signed_positive "(bvsge %1 (_ bv0 16))"

  syntax function rotate_left_bv "(bvor (bvshl %1 (bvurem %2 (_ bv16 16))) (bvlshr %1 (bvsub (_ bv16 16) (bvurem %2 (_ bv16 16)))))"
  syntax function rotate_right_bv "(bvor (bvlshr %1 (bvurem %2 (_ bv16 16))) (bvshl %1 (bvsub (_ bv16 16) (bvurem %2 (_ bv16 16)))))"
end

theory bv.BV8
  meta "literal:keep" type t

  syntax literal t (* "#b%8b"  *) "#x%2x"
  syntax type t "(_ BitVec 8)"

  syntax function zeros "#x00"
  syntax function one   "#x01"
  syntax function ones  "#xFF"
  syntax function size_bv "(_ bv8 8)"

  syntax predicate is_signed_positive "(bvsge %1 (_ bv0 8))"

  syntax function rotate_left_bv "(bvor (bvshl %1 (bvurem %2 (_ bv8 8))) (bvlshr %1 (bvsub (_ bv8 8) (bvurem %2 (_ bv8 8)))))"
  syntax function rotate_right_bv "(bvor (bvlshr %1 (bvurem %2 (_ bv8 8))) (bvshl %1 (bvsub (_ bv8 8) (bvurem %2 (_ bv8 8)))))"
end

theory bv.BVConverter_Gen
  remove allprops
end

theory bv.BVConverter_32_64
  syntax function toBig "((_ zero_extend 32) %1)"
  syntax function toSmall "((_ extract 31 0) %1)"
end

theory bv.BVConverter_16_64
  syntax function toBig "((_ zero_extend 48) %1)"
  syntax function toSmall "((_ extract 15 0) %1)"
end

theory bv.BVConverter_8_64
  syntax function toBig "((_ zero_extend 56) %1)"
  syntax function toSmall "((_ extract 7 0) %1)"
end

theory bv.BVConverter_16_32
  syntax function toBig "((_ zero_extend 16) %1)"
  syntax function toSmall "((_ extract 15 0) %1)"
end

theory bv.BVConverter_8_32
  syntax function toBig "((_ zero_extend 24) %1)"
  syntax function toSmall "((_ extract 7 0) %1)"
end

theory bv.BVConverter_8_16
  syntax function toBig "((_ zero_extend 8) %1)"
  syntax function toSmall "((_ extract 7 0) %1)"
end

theory bv.Pow2int
  remove allprops
end

*)