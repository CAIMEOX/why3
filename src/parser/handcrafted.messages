program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE LEFTPAR RANGE WRITES
##
## Ends in an error in state: 86.
##
## comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
## ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
## ty_arg -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE LEFTPAR WRITES
##
## Ends in an error in state: 76.
##
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## ty_arg -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE RANGE ARROW QUOTE_LIDENT WHILE
##
## Ends in an error in state: 101.
##
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## ty -> ty ARROW ty . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## ty ARROW ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE RANGE ARROW WRITES
##
## Ends in an error in state: 100.
##
## ty -> ty ARROW . ty [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## ty ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE RANGE RANGE WHILE
##
## Ends in an error in state: 95.
##
## nonempty_list(ty_arg) -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## nonempty_list(ty_arg) -> ty_arg . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE RANGE WHILE
##
## Ends in an error in state: 94.
##
## ty -> lqualid . nonempty_list(ty_arg) [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## ty_arg -> lqualid . [ WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## lqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE RANGE WRITES
##
## Ends in an error in state: 962.
##
## pdecl -> EXCEPTION labels(uident_nq) ty . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## ty -> ty . ARROW ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## EXCEPTION labels(uident_nq) ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION UIDENT_QUOTE WITH
##
## Ends in an error in state: 961.
##
## pdecl -> EXCEPTION labels(uident_nq) . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## pdecl -> EXCEPTION labels(uident_nq) . ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION labels(uident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production list(label) ->
## In state 7, spurious reduction of production labels(uident_nq) -> uident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE EXCEPTION WRITES
##
## Ends in an error in state: 960.
##
## pdecl -> EXCEPTION . labels(uident_nq) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## pdecl -> EXCEPTION . labels(uident_nq) ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXCEPTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET LEMMA FALSE
##
## Ends in an error in state: 955.
##
## pdecl -> LET top_ghost . labels(lident_rich) fun_defn [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## pdecl -> LET top_ghost . labels(lident_rich) EQUAL fun_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET top_ghost
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE EQUAL FUN UNDERSCORE ARROW DIVERGES WITH
##
## Ends in an error in state: 746.
##
## fun_expr -> FUN binders spec ARROW spec . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN binders spec ARROW spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE EQUAL FUN UNDERSCORE ARROW WITH
##
## Ends in an error in state: 745.
##
## fun_expr -> FUN binders spec ARROW . spec seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN binders spec ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE EQUAL FUN UNDERSCORE DIVERGES ANY
##
## Ends in an error in state: 744.
##
## fun_expr -> FUN binders spec . ARROW spec seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN binders spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE EQUAL FUN UNDERSCORE EQUAL
##
## Ends in an error in state: 743.
##
## fun_expr -> FUN binders . spec ARROW spec seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN binders
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 840, spurious reduction of production nonempty_list(binder) -> binder
## In state 702, spurious reduction of production binders -> nonempty_list(binder)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE EQUAL FUN WRITES
##
## Ends in an error in state: 742.
##
## fun_expr -> FUN . binders spec ARROW spec seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FUN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE EQUAL WRITES
##
## Ends in an error in state: 957.
##
## pdecl -> LET top_ghost labels(lident_rich) EQUAL . fun_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_rich) EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE LEFTPAR GHOST RANGE WRITES
##
## Ends in an error in state: 687.
##
## binder -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder_vars_head -> ty . [ UNDERSCORE STRING POSITION COLON ]
## ty -> ty . ARROW ty [ UNDERSCORE STRING RIGHTPAR POSITION COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE LEFTPAR GHOST UNDERSCORE COLON FLOAT WRITES
##
## Ends in an error in state: 692.
##
## binder -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST binder_vars cast
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE LEFTPAR GHOST WRITES
##
## Ends in an error in state: 686.
##
## binder -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE LEFTPAR UNDERSCORE COLON FLOAT WRITES
##
## Ends in an error in state: 697.
##
## binder -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR binder_vars cast
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE LEFTPAR WRITES
##
## Ends in an error in state: 685.
##
## binder -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT POSITION OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## ty_arg -> LEFTPAR . RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT POSITION OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT POSITION OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE RANGE STRING WITH
##
## Ends in an error in state: 700.
##
## binder -> ty_arg label . list(label) [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ty_arg label
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE RANGE WITH
##
## Ends in an error in state: 699.
##
## binder -> ty_arg . [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
## binder -> ty_arg . label list(label) [ WRITES VARIANT UNDERSCORE UIDENT_QUOTE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE ARROW
##
## Ends in an error in state: 871.
##
## fun_defn -> binders . option(cast) spec EQUAL spec seq_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 840, spurious reduction of production nonempty_list(binder) -> binder
## In state 702, spurious reduction of production binders -> nonempty_list(binder)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE COLON FLOAT WITH
##
## Ends in an error in state: 872.
##
## fun_defn -> binders option(cast) . spec EQUAL spec seq_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders option(cast)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
## In state 263, spurious reduction of production option(cast) -> cast
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE DIVERGES THEORY
##
## Ends in an error in state: 671.
##
## spec -> single_spec . spec [ WITH WHILE VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## single_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE DIVERGES WITH
##
## Ends in an error in state: 873.
##
## fun_defn -> binders option(cast) spec . EQUAL spec seq_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders option(cast) spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL ABSTRACT DIVERGES WITH
##
## Ends in an error in state: 757.
##
## expr_ -> ABSTRACT spec . seq_expr END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## ABSTRACT spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL ABSTRACT UIDENT_QUOTE WITH
##
## Ends in an error in state: 758.
##
## expr_ -> ABSTRACT spec seq_expr . END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## ABSTRACT spec seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL ABSTRACT WITH
##
## Ends in an error in state: 756.
##
## expr_ -> ABSTRACT . spec seq_expr END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## ABSTRACT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL ABSURD WRITES
##
## Ends in an error in state: 827.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## seq_expr -> expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## seq_expr -> expr . SEMICOLON [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## seq_expr -> expr . SEMICOLON seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL ANY WRITES
##
## Ends in an error in state: 753.
##
## expr_ -> ANY . simple_type_c [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## ANY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL BEGIN UIDENT_QUOTE WITH
##
## Ends in an error in state: 909.
##
## expr_sub -> BEGIN seq_expr . END [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## BEGIN seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL BEGIN WRITES
##
## Ends in an error in state: 727.
##
## expr_sub -> BEGIN . seq_expr END [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> BEGIN . END [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## BEGIN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL CHECK LEFTBRC UIDENT_QUOTE WITH
##
## Ends in an error in state: 789.
##
## expr_ -> assertion_kind LEFTBRC term . RIGHTBRC [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## assertion_kind LEFTBRC term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL CHECK LEFTBRC WRITES
##
## Ends in an error in state: 788.
##
## expr_ -> assertion_kind LEFTBRC . term RIGHTBRC [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## assertion_kind LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL CHECK WRITES
##
## Ends in an error in state: 787.
##
## expr_ -> assertion_kind . LEFTBRC term RIGHTBRC [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## assertion_kind
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL DIVERGES WITH
##
## Ends in an error in state: 875.
##
## fun_defn -> binders option(cast) spec EQUAL spec . seq_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders option(cast) spec EQUAL spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL UIDENT_QUOTE TO UIDENT_QUOTE DO INVARIANT LEFTBRC EPSILON RIGHTBRC WITH
##
## Ends in an error in state: 836.
##
## expr_ -> FOR lident EQUAL seq_expr for_direction seq_expr DO list(invariant) . seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL seq_expr for_direction seq_expr DO list(invariant)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 382, spurious reduction of production list(invariant) ->
## In state 383, spurious reduction of production list(invariant) -> invariant list(invariant)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL UIDENT_QUOTE TO UIDENT_QUOTE DO UIDENT_QUOTE WITH
##
## Ends in an error in state: 837.
##
## expr_ -> FOR lident EQUAL seq_expr for_direction seq_expr DO list(invariant) seq_expr . DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL seq_expr for_direction seq_expr DO list(invariant) seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL UIDENT_QUOTE TO UIDENT_QUOTE DO WRITES
##
## Ends in an error in state: 835.
##
## expr_ -> FOR lident EQUAL seq_expr for_direction seq_expr DO . list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL seq_expr for_direction seq_expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL UIDENT_QUOTE TO UIDENT_QUOTE WITH
##
## Ends in an error in state: 834.
##
## expr_ -> FOR lident EQUAL seq_expr for_direction seq_expr . DO list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL seq_expr for_direction seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL UIDENT_QUOTE TO WRITES
##
## Ends in an error in state: 833.
##
## expr_ -> FOR lident EQUAL seq_expr for_direction . seq_expr DO list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL seq_expr for_direction
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 830.
##
## expr_ -> FOR lident EQUAL seq_expr . for_direction seq_expr DO list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE EQUAL WRITES
##
## Ends in an error in state: 749.
##
## expr_ -> FOR lident EQUAL . seq_expr for_direction seq_expr DO list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR RANGE WRITES
##
## Ends in an error in state: 748.
##
## expr_ -> FOR lident . EQUAL seq_expr for_direction seq_expr DO list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR lident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL FOR WRITES
##
## Ends in an error in state: 747.
##
## expr_ -> FOR . lident EQUAL seq_expr for_direction seq_expr DO list(invariant) seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL GHOST ABSURD WRITES
##
## Ends in an error in state: 843.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> GHOST expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## GHOST expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL GHOST WRITES
##
## Ends in an error in state: 741.
##
## expr_ -> GHOST . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## GHOST
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL IF UIDENT_QUOTE THEN ABSURD WRITES
##
## Ends in an error in state: 846.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> IF seq_expr THEN expr . ELSE expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> IF seq_expr THEN expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL IF UIDENT_QUOTE THEN UIDENT_QUOTE ELSE ABSURD WRITES
##
## Ends in an error in state: 848.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> IF seq_expr THEN expr ELSE expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN expr ELSE expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL IF UIDENT_QUOTE THEN UIDENT_QUOTE ELSE WRITES
##
## Ends in an error in state: 847.
##
## expr_ -> IF seq_expr THEN expr ELSE . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN expr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL IF UIDENT_QUOTE THEN WRITES
##
## Ends in an error in state: 845.
##
## expr_ -> IF seq_expr THEN . expr ELSE expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> IF seq_expr THEN . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF seq_expr THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL IF UIDENT_QUOTE WITH
##
## Ends in an error in state: 844.
##
## expr_ -> IF seq_expr . THEN expr ELSE expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> IF seq_expr . THEN expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL IF WRITES
##
## Ends in an error in state: 740.
##
## expr_ -> IF . seq_expr THEN expr ELSE expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> IF . seq_expr THEN expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC RANGE EQUAL UIDENT_QUOTE SEMICOLON WRITES
##
## Ends in an error in state: 915.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL expr SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC RANGE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 914.
##
## expr_ -> expr . AMPAMP expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ SEMICOLON RIGHTBRC OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL expr . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC RANGE EQUAL WRITES
##
## Ends in an error in state: 913.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid EQUAL . expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC UIDENT_QUOTE VAL
##
## Ends in an error in state: 920.
##
## expr_sub -> LEFTBRC expr_arg . WITH field_list1(expr) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg . LEFTSQ expr RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ expr LARROW expr RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT expr RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT RIGHTSQ [ WITH LEFTSQ DOT ]
## expr_sub -> expr_arg . LEFTSQ DOTDOT expr RIGHTSQ [ WITH LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## LEFTBRC expr_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 823, spurious reduction of production mk_expr(expr_arg_) -> expr_arg_
## In state 767, spurious reduction of production expr_arg -> mk_expr(expr_arg_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC UIDENT_QUOTE WITH RANGE WRITES
##
## Ends in an error in state: 917.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,expr)) -> lqualid . EQUAL expr SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,expr)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 921.
##
## expr_sub -> LEFTBRC expr_arg WITH . field_list1(expr) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTBRC expr_arg WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTBRC WRITES
##
## Ends in an error in state: 725.
##
## expr_sub -> LEFTBRC . field_list1(expr) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> LEFTBRC . expr_arg WITH field_list1(expr) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTPAR OPPREF WRITES
##
## Ends in an error in state: 724.
##
## expr_arg_ -> OPPREF . expr_arg [ UIDENT_QUOTE UIDENT TRUE SEMICOLON RIGHTPAR REAL RANGE OPPREF OP4 OP3 OP2 OP1 MODEL LTGT LT LIDENT_QUOTE LIDENT LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER GT FLOAT FALSE EQUAL COMMA COLON BEGIN BARBAR AMPAMP ]
## expr_dot_ -> OPPREF . expr_dot [ DOT ]
## lident_op -> OPPREF . [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## OPPREF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTPAR RIGHTPAR WRITES
##
## Ends in an error in state: 772.
##
## expr_arg_ -> expr_sub . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_dot_ -> expr_sub . [ DOT ]
##
## The known suffix of the stack is as follows:
## expr_sub
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTPAR UIDENT_QUOTE COMMA ABSURD WITH
##
## Ends in an error in state: 928.
##
## expr_sub -> LEFTPAR comma_list2(expr) . RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR comma_list2(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 899, spurious reduction of production separated_nonempty_list(COMMA,expr) -> expr
## In state 898, spurious reduction of production comma_list1(expr) -> separated_nonempty_list(COMMA,expr)
## In state 902, spurious reduction of production comma_list2(expr) -> expr COMMA comma_list1(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTPAR UIDENT_QUOTE WITH
##
## Ends in an error in state: 926.
##
## expr_sub -> LEFTPAR seq_expr . RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 896, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LEFTPAR WRITES
##
## Ends in an error in state: 722.
##
## expr_sub -> LEFTPAR . seq_expr RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> LEFTPAR . RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> LEFTPAR . comma_list2(expr) RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR WRITES
##
## Ends in an error in state: 855.
##
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ UNDERSCORE UIDENT_QUOTE UIDENT STRING RANGE QUOTE_LIDENT POSITION OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ]
## pat_arg_ -> LEFTPAR . RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
## pat_arg_ -> LEFTPAR . pattern_ RIGHTPAR [ EQUAL COMMA COLON BAR AS ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR EQUAL UIDENT_QUOTE IN WRITES
##
## Ends in an error in state: 866.
##
## expr_ -> LET top_ghost labels(lident_op_id) EQUAL seq_expr IN . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_op_id) EQUAL seq_expr IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 865.
##
## expr_ -> LET top_ghost labels(lident_op_id) EQUAL seq_expr . IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_op_id) EQUAL seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR EQUAL WRITES
##
## Ends in an error in state: 864.
##
## expr_ -> LET top_ghost labels(lident_op_id) EQUAL . seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_op_id) EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR POSITION WRITES
##
## Ends in an error in state: 863.
##
## expr_ -> LET top_ghost labels(lident_op_id) . EQUAL seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET top_ghost labels(lident_op_id) . fun_defn IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_op_id)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 862, spurious reduction of production labels(lident_op_id) -> lident_op_id list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR UNDERSCORE EQUAL UIDENT_QUOTE IN WRITES
##
## Ends in an error in state: 869.
##
## expr_ -> LET top_ghost labels(lident_op_id) fun_defn IN . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_op_id) fun_defn IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR UNDERSCORE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 868.
##
## expr_ -> LET top_ghost labels(lident_op_id) fun_defn . IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_op_id) fun_defn
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
## In state 876, spurious reduction of production fun_defn -> binders option(cast) spec EQUAL spec seq_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEFTPAR_STAR_RIGHTPAR WRITES
##
## Ends in an error in state: 861.
##
## labels(lident_op_id) -> lident_op_id . list(label) [ UNDERSCORE UIDENT_QUOTE UIDENT RANGE QUOTE_LIDENT OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR FLOAT EQUAL ]
##
## The known suffix of the stack is as follows:
## lident_op_id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET LEMMA FALSE
##
## Ends in an error in state: 854.
##
## expr_ -> LET top_ghost . pattern EQUAL seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET top_ghost . labels(lident_op_id) EQUAL seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET top_ghost . labels(lident_nq) fun_defn IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET top_ghost . labels(lident_op_id) fun_defn IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE IN WRITES
##
## Ends in an error in state: 879.
##
## expr_ -> LET top_ghost labels(lident_nq) fun_defn IN . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_nq) fun_defn IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 878.
##
## expr_ -> LET top_ghost labels(lident_nq) fun_defn . IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_nq) fun_defn
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
## In state 876, spurious reduction of production fun_defn -> binders option(cast) spec EQUAL spec seq_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET RANGE WITH
##
## Ends in an error in state: 877.
##
## expr_ -> LET top_ghost labels(lident_nq) . fun_defn IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## pat_arg_ -> labels(lident_nq) . [ EQUAL COMMA COLON BAR AS ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 46, spurious reduction of production list(label) ->
## In state 47, spurious reduction of production labels(lident_nq) -> lident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET REC RANGE FLOAT EQUAL UIDENT_QUOTE IN WRITES
##
## Ends in an error in state: 739.
##
## expr_ -> LET REC with_list1(rec_defn) IN . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET REC with_list1(rec_defn) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET REC RANGE FLOAT EQUAL UIDENT_QUOTE VAL
##
## Ends in an error in state: 738.
##
## expr_ -> LET REC with_list1(rec_defn) . IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET REC with_list1(rec_defn)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
## In state 954, spurious reduction of production rec_defn -> top_ghost labels(lident_rich) binders option(cast) spec EQUAL spec seq_expr
## In state 851, spurious reduction of production separated_nonempty_list(WITH,rec_defn) -> rec_defn
## In state 850, spurious reduction of production with_list1(rec_defn) -> separated_nonempty_list(WITH,rec_defn)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET REC WRITES
##
## Ends in an error in state: 737.
##
## expr_ -> LET REC . with_list1(rec_defn) IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET REC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET UNDERSCORE EQUAL UIDENT_QUOTE IN WRITES
##
## Ends in an error in state: 859.
##
## expr_ -> LET top_ghost pattern EQUAL seq_expr IN . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost pattern EQUAL seq_expr IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET UNDERSCORE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 858.
##
## expr_ -> LET top_ghost pattern EQUAL seq_expr . IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost pattern EQUAL seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET UNDERSCORE EQUAL WRITES
##
## Ends in an error in state: 857.
##
## expr_ -> LET top_ghost pattern EQUAL . seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost pattern EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET UNDERSCORE SEMICOLON
##
## Ends in an error in state: 856.
##
## expr_ -> LET top_ghost pattern . EQUAL seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET top_ghost pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production pat_conj_ -> pat_uni_
## In state 209, spurious reduction of production pattern_ -> pat_conj_
## In state 204, spurious reduction of production mk_pat(pattern_) -> pattern_
## In state 211, spurious reduction of production pattern -> mk_pat(pattern_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LET WRITES
##
## Ends in an error in state: 736.
##
## expr_ -> LET . top_ghost pattern EQUAL seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET . top_ghost labels(lident_op_id) EQUAL seq_expr IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET . top_ghost labels(lident_nq) fun_defn IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET . top_ghost labels(lident_op_id) fun_defn IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> LET . REC with_list1(rec_defn) IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LOOP INVARIANT LEFTBRC EPSILON RIGHTBRC WRITES
##
## Ends in an error in state: 733.
##
## loop_annotation -> invariant . loop_annotation [ WHILE VAL UIDENT_QUOTE UIDENT TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT POSITION OPPREF OP4 OP3 OP2 OP1 NOT MODEL MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER IF GT GHOST FUN FOR FLOAT FALSE CHECK BEGIN ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## invariant
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LOOP UIDENT_QUOTE WITH
##
## Ends in an error in state: 881.
##
## expr_ -> LOOP loop_annotation seq_expr . END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LOOP loop_annotation seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LOOP VARIANT LEFTBRC EPSILON RIGHTBRC WRITES
##
## Ends in an error in state: 731.
##
## loop_annotation -> variant . loop_annotation [ WHILE VAL UIDENT_QUOTE UIDENT TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT POSITION OPPREF OP4 OP3 OP2 OP1 NOT MODEL MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER IF GT GHOST FUN FOR FLOAT FALSE CHECK BEGIN ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## variant
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL LOOP WRITES
##
## Ends in an error in state: 730.
##
## expr_ -> LOOP . loop_annotation seq_expr END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## LOOP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE COMMA ABSURD RIGHTPAR
##
## Ends in an error in state: 903.
##
## expr_ -> MATCH comma_list2(expr) . WITH match_cases(seq_expr) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH comma_list2(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 899, spurious reduction of production separated_nonempty_list(COMMA,expr) -> expr
## In state 898, spurious reduction of production comma_list1(expr) -> separated_nonempty_list(COMMA,expr)
## In state 902, spurious reduction of production comma_list2(expr) -> expr COMMA comma_list1(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE COMMA ABSURD WITH WRITES
##
## Ends in an error in state: 904.
##
## expr_ -> MATCH comma_list2(expr) WITH . match_cases(seq_expr) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH comma_list2(expr) WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE COMMA UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 900.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ WITH RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE COMMA UIDENT_QUOTE VAL
##
## Ends in an error in state: 899.
##
## expr_ -> expr . AMPAMP expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ WITH RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## separated_nonempty_list(COMMA,expr) -> expr . [ WITH RIGHTPAR ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ WITH RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 897.
##
## comma_list2(expr) -> expr COMMA . comma_list1(expr) [ WITH RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE RIGHTPAR
##
## Ends in an error in state: 883.
##
## expr_ -> MATCH seq_expr . WITH match_cases(seq_expr) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 896, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE VAL
##
## Ends in an error in state: 896.
##
## comma_list2(expr) -> expr . COMMA comma_list1(expr) [ WITH RIGHTPAR ]
## expr_ -> expr . AMPAMP expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ WITH SEMICOLON RIGHTPAR OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COMMA COLON BARBAR AMPAMP ]
## seq_expr -> expr . [ WITH RIGHTPAR ]
## seq_expr -> expr . SEMICOLON [ WITH RIGHTPAR ]
## seq_expr -> expr . SEMICOLON seq_expr [ WITH RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE WITH BAR WRITES
##
## Ends in an error in state: 885.
##
## bar_list1(separated_pair(pattern,ARROW,seq_expr)) -> BAR . separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) [ END ]
##
## The known suffix of the stack is as follows:
## BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE WITH UNDERSCORE ARROW UIDENT_QUOTE BAR WRITES
##
## Ends in an error in state: 890.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern ARROW seq_expr BAR . separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) [ END ]
##
## The known suffix of the stack is as follows:
## pattern ARROW seq_expr BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE WITH UNDERSCORE ARROW UIDENT_QUOTE WITH
##
## Ends in an error in state: 889.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern ARROW seq_expr . [ END ]
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern ARROW seq_expr . BAR separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) [ END ]
##
## The known suffix of the stack is as follows:
## pattern ARROW seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE WITH UNDERSCORE ARROW WRITES
##
## Ends in an error in state: 888.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern ARROW . seq_expr [ END ]
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern ARROW . seq_expr BAR separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) [ END ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE WITH UNDERSCORE SEMICOLON
##
## Ends in an error in state: 887.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern . ARROW seq_expr [ END ]
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) -> pattern . ARROW seq_expr BAR separated_nonempty_list(BAR,separated_pair(pattern,ARROW,seq_expr)) [ END ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production pat_conj_ -> pat_uni_
## In state 209, spurious reduction of production pattern_ -> pat_conj_
## In state 204, spurious reduction of production mk_pat(pattern_) -> pattern_
## In state 211, spurious reduction of production pattern -> mk_pat(pattern_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 884.
##
## expr_ -> MATCH seq_expr WITH . match_cases(seq_expr) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH seq_expr WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL MATCH WRITES
##
## Ends in an error in state: 729.
##
## expr_ -> MATCH . seq_expr WITH match_cases(seq_expr) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> MATCH . comma_list2(expr) WITH match_cases(seq_expr) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL NOT WRITES
##
## Ends in an error in state: 728.
##
## expr_ -> NOT . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## NOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL OP4 WRITES
##
## Ends in an error in state: 764.
##
## expr_ -> prefix_op . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## prefix_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL OPPREF WRITES
##
## Ends in an error in state: 721.
##
## expr_arg_ -> OPPREF . expr_arg [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_dot_ -> OPPREF . expr_dot [ DOT ]
##
## The known suffix of the stack is as follows:
## OPPREF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL QUOTE_UIDENT COLON WRITES
##
## Ends in an error in state: 761.
##
## expr_ -> quote_uident COLON . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## quote_uident COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL QUOTE_UIDENT WRITES
##
## Ends in an error in state: 760.
##
## expr_ -> quote_uident . COLON seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## quote_uident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL RAISE LEFTPAR UIDENT_QUOTE UIDENT_QUOTE WITH
##
## Ends in an error in state: 930.
##
## expr_ -> RAISE LEFTPAR uqualid seq_expr . RIGHTPAR [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## RAISE LEFTPAR uqualid seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL RAISE LEFTPAR UIDENT_QUOTE WRITES
##
## Ends in an error in state: 720.
##
## expr_ -> RAISE LEFTPAR uqualid . seq_expr RIGHTPAR [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## uqualid -> uqualid . DOT UIDENT [ WHILE VAL UIDENT_QUOTE UIDENT TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT POSITION OPPREF OP4 OP3 OP2 OP1 NOT MODEL MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER IF GT GHOST FUN FOR FLOAT FALSE DOT CHECK BEGIN ASSUME ASSERT ANY ABSURD ABSTRACT ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ WHILE VAL UIDENT_QUOTE UIDENT TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT POSITION OPPREF OP4 OP3 OP2 OP1 NOT MODEL MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER IF GT GHOST FUN FOR FLOAT FALSE DOT CHECK BEGIN ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## RAISE LEFTPAR uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL RAISE LEFTPAR WRITES
##
## Ends in an error in state: 719.
##
## expr_ -> RAISE LEFTPAR . uqualid seq_expr RIGHTPAR [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## RAISE LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL RAISE UIDENT_QUOTE WRITES
##
## Ends in an error in state: 932.
##
## expr_ -> RAISE uqualid . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## uqualid -> uqualid . DOT UIDENT [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## RAISE uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL RAISE WRITES
##
## Ends in an error in state: 718.
##
## expr_ -> RAISE . uqualid [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> RAISE . LEFTPAR uqualid seq_expr RIGHTPAR [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## RAISE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL RANGE DOT WRITES
##
## Ends in an error in state: 775.
##
## expr_sub -> expr_dot DOT . lqualid_rich [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_dot DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL STRING ABSURD WRITES
##
## Ends in an error in state: 825.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> label expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## label expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL STRING WRITES
##
## Ends in an error in state: 770.
##
## expr_ -> label . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## label
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE VAL
##
## Ends in an error in state: 933.
##
## expr_ -> TRY seq_expr . WITH bar_list1(exn_handler) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## TRY seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH BAR WRITES
##
## Ends in an error in state: 935.
##
## bar_list1(exn_handler) -> BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
##
## The known suffix of the stack is as follows:
## BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH UIDENT_QUOTE ARROW ABSURD BAR WRITES
##
## Ends in an error in state: 943.
##
## separated_nonempty_list(BAR,exn_handler) -> exn_handler BAR . separated_nonempty_list(BAR,exn_handler) [ END ]
##
## The known suffix of the stack is as follows:
## exn_handler BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH UIDENT_QUOTE ARROW ABSURD WITH
##
## Ends in an error in state: 942.
##
## separated_nonempty_list(BAR,exn_handler) -> exn_handler . [ END ]
## separated_nonempty_list(BAR,exn_handler) -> exn_handler . BAR separated_nonempty_list(BAR,exn_handler) [ END ]
##
## The known suffix of the stack is as follows:
## exn_handler
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 827, spurious reduction of production seq_expr -> expr
## In state 940, spurious reduction of production exn_handler -> uqualid option(pat_arg) ARROW seq_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH UIDENT_QUOTE ARROW WRITES
##
## Ends in an error in state: 939.
##
## exn_handler -> uqualid option(pat_arg) ARROW . seq_expr [ END BAR ]
##
## The known suffix of the stack is as follows:
## uqualid option(pat_arg) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH UIDENT_QUOTE UNDERSCORE ANY
##
## Ends in an error in state: 938.
##
## exn_handler -> uqualid option(pat_arg) . ARROW seq_expr [ END BAR ]
##
## The known suffix of the stack is as follows:
## uqualid option(pat_arg)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH UIDENT_QUOTE WRITES
##
## Ends in an error in state: 936.
##
## exn_handler -> uqualid . option(pat_arg) ARROW seq_expr [ END BAR ]
## uqualid -> uqualid . DOT UIDENT [ UNDERSCORE UIDENT_QUOTE UIDENT RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT DOT ARROW ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ UNDERSCORE UIDENT_QUOTE UIDENT RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT DOT ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 934.
##
## expr_ -> TRY seq_expr WITH . bar_list1(exn_handler) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## TRY seq_expr WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL TRY WRITES
##
## Ends in an error in state: 716.
##
## expr_ -> TRY . seq_expr WITH bar_list1(exn_handler) END [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## TRY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE AMPAMP ABSURD WRITES
##
## Ends in an error in state: 810.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr AMPAMP expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr AMPAMP expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE AMPAMP WRITES
##
## Ends in an error in state: 809.
##
## expr_ -> expr AMPAMP . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr AMPAMP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE BARBAR ABSURD WRITES
##
## Ends in an error in state: 808.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr BARBAR expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr BARBAR expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE BARBAR WRITES
##
## Ends in an error in state: 807.
##
## expr_ -> expr BARBAR . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr BARBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE EQUAL ABSURD WRITES
##
## Ends in an error in state: 806.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr EQUAL expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr EQUAL expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 805.
##
## expr_ -> expr EQUAL . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE GT ABSURD WRITES
##
## Ends in an error in state: 804.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr GT expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr GT expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE GT WRITES
##
## Ends in an error in state: 803.
##
## expr_ -> expr GT . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LARROW UIDENT_QUOTE LARROW
##
## Ends in an error in state: 798.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr LARROW expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr LARROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LARROW WRITES
##
## Ends in an error in state: 797.
##
## expr_ -> expr LARROW . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr LARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ DOTDOT UIDENT_QUOTE WITH
##
## Ends in an error in state: 782.
##
## expr_ -> expr . AMPAMP expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_sub -> expr_arg LEFTSQ DOTDOT expr . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ DOTDOT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ DOTDOT WRITES
##
## Ends in an error in state: 780.
##
## expr_sub -> expr_arg LEFTSQ DOTDOT . expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ DOTDOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ UIDENT_QUOTE DOTDOT UIDENT_QUOTE WITH
##
## Ends in an error in state: 818.
##
## expr_ -> expr . AMPAMP expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL COLON BARBAR AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr DOTDOT expr . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr DOTDOT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ UIDENT_QUOTE DOTDOT WRITES
##
## Ends in an error in state: 816.
##
## expr_sub -> expr_arg LEFTSQ expr DOTDOT . expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr DOTDOT . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr DOTDOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ UIDENT_QUOTE LARROW UIDENT_QUOTE WITH
##
## Ends in an error in state: 814.
##
## expr_ -> expr . AMPAMP expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr LARROW expr . [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr LARROW expr . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr LARROW expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ UIDENT_QUOTE LARROW WRITES
##
## Ends in an error in state: 813.
##
## expr_ -> expr LARROW . expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr LARROW . expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr LARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ UIDENT_QUOTE WITH
##
## Ends in an error in state: 811.
##
## expr_ -> expr . AMPAMP expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . BARBAR expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP1 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP2 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP3 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . OP4 expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . EQUAL expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . LTGT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . LT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . GT expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . LARROW expr [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_ -> expr . cast [ RIGHTSQ OP4 OP3 OP2 OP1 LTGT LT LARROW GT EQUAL DOTDOT COLON BARBAR AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr . LARROW expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr . DOTDOT expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ expr . DOTDOT RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LEFTSQ WRITES
##
## Ends in an error in state: 779.
##
## expr_sub -> expr_arg LEFTSQ . expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ . expr LARROW expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ . expr DOTDOT expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ . expr DOTDOT RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg LEFTSQ . DOTDOT expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg LEFTSQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LT ABSURD WRITES
##
## Ends in an error in state: 802.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr LT expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr LT expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LT WRITES
##
## Ends in an error in state: 801.
##
## expr_ -> expr LT . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LTGT ABSURD WRITES
##
## Ends in an error in state: 800.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr LTGT expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr LTGT expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE LTGT WRITES
##
## Ends in an error in state: 799.
##
## expr_ -> expr LTGT . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr LTGT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP1 ABSURD WRITES
##
## Ends in an error in state: 796.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr OP1 expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP1 expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP1 WRITES
##
## Ends in an error in state: 795.
##
## expr_ -> expr OP1 . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP1
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP2 ABSURD WRITES
##
## Ends in an error in state: 794.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr OP2 expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP2 expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP2 WRITES
##
## Ends in an error in state: 793.
##
## expr_ -> expr OP2 . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP2
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP3 ABSURD WRITES
##
## Ends in an error in state: 792.
##
## expr_ -> expr . AMPAMP expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . BARBAR expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP1 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP2 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP3 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr OP3 expr . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . OP4 expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . EQUAL expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LTGT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . GT expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . LARROW expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## expr_ -> expr . cast [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP3 expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP3 WRITES
##
## Ends in an error in state: 791.
##
## expr_ -> expr OP3 . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP3
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE OP4 WRITES
##
## Ends in an error in state: 784.
##
## expr_ -> expr OP4 . expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr OP4
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE SEMICOLON WRITES
##
## Ends in an error in state: 828.
##
## seq_expr -> expr SEMICOLON . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## seq_expr -> expr SEMICOLON . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE SO
##
## Ends in an error in state: 777.
##
## expr_ -> expr_arg_ . [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## mk_expr(expr_arg_) -> expr_arg_ . [ UIDENT_QUOTE UIDENT TRUE REAL RANGE OPPREF MODEL LIDENT_QUOTE LIDENT LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER FLOAT FALSE BEGIN ]
##
## The known suffix of the stack is as follows:
## expr_arg_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL UIDENT_QUOTE UIDENT_QUOTE SO
##
## Ends in an error in state: 824.
##
## expr_sub -> expr_arg . LEFTSQ expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg . LEFTSQ expr LARROW expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg . LEFTSQ expr DOTDOT RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## expr_sub -> expr_arg . LEFTSQ DOTDOT expr RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
## located(expr_arg) -> expr_arg . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## expr_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 823, spurious reduction of production mk_expr(expr_arg_) -> expr_arg_
## In state 767, spurious reduction of production expr_arg -> mk_expr(expr_arg_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL VAL LEMMA FALSE
##
## Ends in an error in state: 710.
##
## expr_ -> VAL top_ghost . labels(lident_rich) mk_expr(val_expr) IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## VAL top_ghost
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL VAL RANGE COLON FLOAT IN WRITES
##
## Ends in an error in state: 715.
##
## expr_ -> VAL top_ghost labels(lident_rich) mk_expr(val_expr) IN . seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## VAL top_ghost labels(lident_rich) mk_expr(val_expr) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL VAL RANGE COLON FLOAT WITH
##
## Ends in an error in state: 714.
##
## expr_ -> VAL top_ghost labels(lident_rich) mk_expr(val_expr) . IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## VAL top_ghost labels(lident_rich) mk_expr(val_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 668, spurious reduction of production spec ->
## In state 670, spurious reduction of production simple_type_c -> ty spec
## In state 673, spurious reduction of production tail_type_c -> COLON simple_type_c
## In state 713, spurious reduction of production val_expr -> tail_type_c
## In state 712, spurious reduction of production mk_expr(val_expr) -> val_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL VAL RANGE WITH
##
## Ends in an error in state: 711.
##
## expr_ -> VAL top_ghost labels(lident_rich) . mk_expr(val_expr) IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## VAL top_ghost labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL VAL WRITES
##
## Ends in an error in state: 709.
##
## expr_ -> VAL . top_ghost labels(lident_rich) mk_expr(val_expr) IN seq_expr [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## VAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL WHILE UIDENT_QUOTE DO UIDENT_QUOTE WITH
##
## Ends in an error in state: 952.
##
## expr_ -> WHILE seq_expr DO loop_annotation seq_expr . DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## WHILE seq_expr DO loop_annotation seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL WHILE UIDENT_QUOTE DO WRITES
##
## Ends in an error in state: 950.
##
## expr_ -> WHILE seq_expr DO . loop_annotation seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## WHILE seq_expr DO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL WHILE UIDENT_QUOTE WITH
##
## Ends in an error in state: 949.
##
## expr_ -> WHILE seq_expr . DO loop_annotation seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## WHILE seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL WHILE WRITES
##
## Ends in an error in state: 708.
##
## expr_ -> WHILE . seq_expr DO loop_annotation seq_expr DONE [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE EQUAL WITH
##
## Ends in an error in state: 874.
##
## fun_defn -> binders option(cast) spec EQUAL . spec seq_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## binders option(cast) spec EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE UNDERSCORE WITH
##
## Ends in an error in state: 840.
##
## nonempty_list(binder) -> binder . [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ]
## nonempty_list(binder) -> binder . nonempty_list(binder) [ WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ]
##
## The known suffix of the stack is as follows:
## binder
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET RANGE WRITES
##
## Ends in an error in state: 956.
##
## pdecl -> LET top_ghost labels(lident_rich) . fun_defn [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## pdecl -> LET top_ghost labels(lident_rich) . EQUAL fun_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET top_ghost labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC LEMMA FALSE
##
## Ends in an error in state: 683.
##
## rec_defn -> top_ghost . labels(lident_rich) binders option(cast) spec EQUAL spec seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE FLOAT EQUAL UIDENT_QUOTE TO
##
## Ends in an error in state: 851.
##
## separated_nonempty_list(WITH,rec_defn) -> rec_defn . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(WITH,rec_defn) -> rec_defn . WITH separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## rec_defn
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 763, spurious reduction of production expr_arg_ -> qualid
## In state 777, spurious reduction of production expr_ -> expr_arg_
## In state 781, spurious reduction of production mk_expr(expr_) -> expr_
## In state 768, spurious reduction of production expr -> mk_expr(expr_)
## In state 827, spurious reduction of production seq_expr -> expr
## In state 954, spurious reduction of production rec_defn -> top_ghost labels(lident_rich) binders option(cast) spec EQUAL spec seq_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE FLOAT EQUAL UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 852.
##
## separated_nonempty_list(WITH,rec_defn) -> rec_defn WITH . separated_nonempty_list(WITH,rec_defn) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## rec_defn WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE UNDERSCORE ARROW
##
## Ends in an error in state: 703.
##
## rec_defn -> top_ghost labels(lident_rich) binders . option(cast) spec EQUAL spec seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost labels(lident_rich) binders
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 840, spurious reduction of production nonempty_list(binder) -> binder
## In state 702, spurious reduction of production binders -> nonempty_list(binder)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE UNDERSCORE COLON FLOAT WITH
##
## Ends in an error in state: 704.
##
## rec_defn -> top_ghost labels(lident_rich) binders option(cast) . spec EQUAL spec seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost labels(lident_rich) binders option(cast)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
## In state 263, spurious reduction of production option(cast) -> cast
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE UNDERSCORE DIVERGES WITH
##
## Ends in an error in state: 705.
##
## rec_defn -> top_ghost labels(lident_rich) binders option(cast) spec . EQUAL spec seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost labels(lident_rich) binders option(cast) spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE UNDERSCORE EQUAL DIVERGES WITH
##
## Ends in an error in state: 707.
##
## rec_defn -> top_ghost labels(lident_rich) binders option(cast) spec EQUAL spec . seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost labels(lident_rich) binders option(cast) spec EQUAL spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE UNDERSCORE EQUAL WITH
##
## Ends in an error in state: 706.
##
## rec_defn -> top_ghost labels(lident_rich) binders option(cast) spec EQUAL . spec seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost labels(lident_rich) binders option(cast) spec EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC RANGE WRITES
##
## Ends in an error in state: 684.
##
## rec_defn -> top_ghost labels(lident_rich) . binders option(cast) spec EQUAL spec seq_expr [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## top_ghost labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET REC WRITES
##
## Ends in an error in state: 681.
##
## pdecl -> LET REC . with_list1(rec_defn) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET REC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE LET WRITES
##
## Ends in an error in state: 680.
##
## pdecl -> LET . top_ghost labels(lident_rich) fun_defn [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## pdecl -> LET . top_ghost labels(lident_rich) EQUAL fun_expr [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## pdecl -> LET . REC with_list1(rec_defn) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE NAMESPACE UIDENT_QUOTE WRITES
##
## Ends in an error in state: 965.
##
## module_decl -> namespace_head . list(module_decl) END [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## namespace_head
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE USE UIDENT WITH
##
## Ends in an error in state: 966.
##
## list(module_decl) -> module_decl . list(module_decl) [ END ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production tqualid -> UIDENT
## In state 35, spurious reduction of production use -> boption(IMPORT) tqualid
## In state 33, spurious reduction of production use_clone -> USE use
## In state 963, spurious reduction of production module_decl -> use_clone
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL LEMMA FALSE
##
## Ends in an error in state: 597.
##
## pdecl -> VAL top_ghost . labels(lident_rich) type_v [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL top_ghost
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE COLON RANGE UNDERSCORE
##
## Ends in an error in state: 668.
##
## simple_type_c -> ty . spec [ WITH VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ]
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM ARROW AMPAMP ]
##
## The known suffix of the stack is as follows:
## ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE COLON WRITES
##
## Ends in an error in state: 667.
##
## tail_type_c -> COLON . simple_type_c [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE DIVERGES DIVERGES WITH
##
## Ends in an error in state: 676.
##
## tail_type_c -> single_spec spec . arrow_type_v [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## single_spec spec
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 671, spurious reduction of production spec ->
## In state 672, spurious reduction of production spec -> single_spec spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE DIVERGES WITH
##
## Ends in an error in state: 675.
##
## tail_type_c -> single_spec . spec arrow_type_v [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## single_spec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE ENSURES LEFTBRC UIDENT_QUOTE WITH
##
## Ends in an error in state: 663.
##
## ensures -> term . [ RIGHTBRC ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE ENSURES LEFTBRC WRITES
##
## Ends in an error in state: 662.
##
## single_spec -> ENSURES LEFTBRC . ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## ENSURES LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE ENSURES WRITES
##
## Ends in an error in state: 661.
##
## single_spec -> ENSURES . LEFTBRC ensures RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## ENSURES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC BAR UIDENT_QUOTE WRITES
##
## Ends in an error in state: 640.
##
## raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
## raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
## uqualid -> uqualid . DOT UIDENT [ UNDERSCORE UIDENT_QUOTE UIDENT RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT DOT ARROW ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ UNDERSCORE UIDENT_QUOTE UIDENT RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT DOT ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC BAR WRITES
##
## Ends in an error in state: 639.
##
## bar_list1(raises) -> BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE ARROW EPSILON BAR WRITES
##
## Ends in an error in state: 648.
##
## separated_nonempty_list(BAR,raises) -> raises BAR . separated_nonempty_list(BAR,raises) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## raises BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE ARROW UIDENT_QUOTE WITH
##
## Ends in an error in state: 642.
##
## raises -> uqualid ARROW term . [ RIGHTBRC BAR ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## uqualid ARROW term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE ARROW WRITES
##
## Ends in an error in state: 641.
##
## raises -> uqualid ARROW . term [ RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## uqualid ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE COMMA UIDENT_QUOTE WRITES
##
## Ends in an error in state: 652.
##
## uqualid -> uqualid . DOT UIDENT [ RIGHTBRC DOT COMMA ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ RIGHTBRC DOT COMMA ]
## xsymbol -> uqualid . [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 651.
##
## separated_nonempty_list(COMMA,xsymbol) -> xsymbol COMMA . separated_nonempty_list(COMMA,xsymbol) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## xsymbol COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE UNDERSCORE ARROW UIDENT_QUOTE WITH
##
## Ends in an error in state: 645.
##
## raises -> uqualid pat_arg ARROW term . [ RIGHTBRC BAR ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR BAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## uqualid pat_arg ARROW term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE UNDERSCORE ARROW WRITES
##
## Ends in an error in state: 644.
##
## raises -> uqualid pat_arg ARROW . term [ RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## uqualid pat_arg ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE UNDERSCORE WRITES
##
## Ends in an error in state: 643.
##
## raises -> uqualid pat_arg . ARROW term [ RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## uqualid pat_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC UIDENT_QUOTE WRITES
##
## Ends in an error in state: 654.
##
## raises -> uqualid . ARROW term [ RIGHTBRC BAR ]
## raises -> uqualid . pat_arg ARROW term [ RIGHTBRC BAR ]
## uqualid -> uqualid . DOT UIDENT [ UNDERSCORE UIDENT_QUOTE UIDENT RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT DOT COMMA ARROW ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ UNDERSCORE UIDENT_QUOTE UIDENT RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT DOT COMMA ARROW ]
## xsymbol -> uqualid . [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES LEFTBRC WRITES
##
## Ends in an error in state: 638.
##
## single_spec -> RAISES LEFTBRC . bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
## single_spec -> RAISES LEFTBRC . comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## RAISES LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RAISES WRITES
##
## Ends in an error in state: 637.
##
## single_spec -> RAISES . LEFTBRC bar_list1(raises) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
## single_spec -> RAISES . LEFTBRC comma_list1(xsymbol) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## RAISES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE READS LEFTBRC RANGE COMMA WRITES
##
## Ends in an error in state: 632.
##
## separated_nonempty_list(COMMA,lqualid) -> lqualid COMMA . separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE READS LEFTBRC RANGE WRITES
##
## Ends in an error in state: 631.
##
## separated_nonempty_list(COMMA,lqualid) -> lqualid . [ RIGHTBRC ]
## separated_nonempty_list(COMMA,lqualid) -> lqualid . COMMA separated_nonempty_list(COMMA,lqualid) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE READS LEFTBRC WRITES
##
## Ends in an error in state: 629.
##
## single_spec -> READS LEFTBRC . comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## READS LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE READS WRITES
##
## Ends in an error in state: 628.
##
## single_spec -> READS . LEFTBRC comma_list0(lqualid) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## READS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE REQUIRES LEFTBRC UIDENT_QUOTE WITH
##
## Ends in an error in state: 626.
##
## single_spec -> REQUIRES LEFTBRC term . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## REQUIRES LEFTBRC term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE REQUIRES LEFTBRC WRITES
##
## Ends in an error in state: 625.
##
## single_spec -> REQUIRES LEFTBRC . term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## REQUIRES LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE REQUIRES WRITES
##
## Ends in an error in state: 624.
##
## single_spec -> REQUIRES . LEFTBRC term RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## REQUIRES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC BAR WRITES
##
## Ends in an error in state: 345.
##
## bar_list1(separated_pair(pattern,ARROW,term)) -> BAR . separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC UNDERSCORE ARROW EPSILON END
##
## Ends in an error in state: 622.
##
## single_spec -> RETURNS LEFTBRC match_cases(term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## RETURNS LEFTBRC match_cases(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 349, spurious reduction of production separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW term
## In state 352, spurious reduction of production bar_list1(separated_pair(pattern,ARROW,term)) -> separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))
## In state 355, spurious reduction of production match_cases(term) -> bar_list1(separated_pair(pattern,ARROW,term))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC UNDERSCORE ARROW UIDENT_QUOTE BAR WRITES
##
## Ends in an error in state: 350.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW term BAR . separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## pattern ARROW term BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC UNDERSCORE ARROW UIDENT_QUOTE WITH
##
## Ends in an error in state: 349.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW term . [ RIGHTBRC END ]
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW term . BAR separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) [ RIGHTBRC END ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL END COLON BY BARBAR BAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## pattern ARROW term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC UNDERSCORE ARROW WRITES
##
## Ends in an error in state: 348.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW . term [ RIGHTBRC END ]
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW . term BAR separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC UNDERSCORE SEMICOLON
##
## Ends in an error in state: 347.
##
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern . ARROW term [ RIGHTBRC END ]
## separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern . ARROW term BAR separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) [ RIGHTBRC END ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production pat_conj_ -> pat_uni_
## In state 209, spurious reduction of production pattern_ -> pat_conj_
## In state 204, spurious reduction of production mk_pat(pattern_) -> pattern_
## In state 211, spurious reduction of production pattern -> mk_pat(pattern_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS LEFTBRC WRITES
##
## Ends in an error in state: 621.
##
## single_spec -> RETURNS LEFTBRC . match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## RETURNS LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE RETURNS WRITES
##
## Ends in an error in state: 620.
##
## single_spec -> RETURNS . LEFTBRC match_cases(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## RETURNS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE UNDERSCORE COINDUCTIVE
##
## Ends in an error in state: 601.
##
## arrow_type_v -> param params . tail_type_c [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## param params
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 418, spurious reduction of production list(param) ->
## In state 419, spurious reduction of production list(param) -> param list(param)
## In state 421, spurious reduction of production params -> list(param)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE VARIANT LEFTBRC UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 615.
##
## separated_nonempty_list(COMMA,single_variant) -> single_variant COMMA . separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## single_variant COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE VARIANT LEFTBRC UIDENT_QUOTE VAL
##
## Ends in an error in state: 610.
##
## single_variant -> term . option(preceded(WITH,lqualid)) [ RIGHTBRC COMMA ]
## term_ -> term . ARROW term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE VARIANT LEFTBRC UIDENT_QUOTE WITH RANGE WRITES
##
## Ends in an error in state: 614.
##
## separated_nonempty_list(COMMA,single_variant) -> single_variant . [ RIGHTBRC ]
## separated_nonempty_list(COMMA,single_variant) -> single_variant . COMMA separated_nonempty_list(COMMA,single_variant) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## single_variant
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE VARIANT LEFTBRC UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 611.
##
## option(preceded(WITH,lqualid)) -> WITH . lqualid [ RIGHTBRC COMMA ]
##
## The known suffix of the stack is as follows:
## WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE VARIANT LEFTBRC WRITES
##
## Ends in an error in state: 609.
##
## variant -> VARIANT LEFTBRC . comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## VARIANT LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE VARIANT WRITES
##
## Ends in an error in state: 608.
##
## variant -> VARIANT . LEFTBRC comma_list1(single_variant) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## VARIANT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE WITH
##
## Ends in an error in state: 600.
##
## arrow_type_v -> param . params tail_type_c [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE IN GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## param
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE WRITES LEFTBRC UIDENT_QUOTE BAR
##
## Ends in an error in state: 606.
##
## single_spec -> WRITES LEFTBRC comma_list0(term) . RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## WRITES LEFTBRC comma_list0(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
## In state 270, spurious reduction of production separated_nonempty_list(COMMA,term) -> term
## In state 604, spurious reduction of production loption(separated_nonempty_list(COMMA,term)) -> separated_nonempty_list(COMMA,term)
## In state 605, spurious reduction of production comma_list0(term) -> loption(separated_nonempty_list(COMMA,term))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE WRITES LEFTBRC UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 310.
##
## separated_nonempty_list(COMMA,term) -> term COMMA . separated_nonempty_list(COMMA,term) [ WITH RIGHTSQ RIGHTPAR RIGHTBRC BAR ]
##
## The known suffix of the stack is as follows:
## term COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE WRITES LEFTBRC UIDENT_QUOTE VAL
##
## Ends in an error in state: 270.
##
## separated_nonempty_list(COMMA,term) -> term . [ WITH RIGHTSQ RIGHTPAR RIGHTBRC BAR ]
## separated_nonempty_list(COMMA,term) -> term . COMMA separated_nonempty_list(COMMA,term) [ WITH RIGHTSQ RIGHTPAR RIGHTBRC BAR ]
## term_ -> term . ARROW term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH SO RIGHTSQ RIGHTPAR RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR BAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE WRITES LEFTBRC WRITES
##
## Ends in an error in state: 603.
##
## single_spec -> WRITES LEFTBRC . comma_list0(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## WRITES LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE UNDERSCORE WRITES WRITES
##
## Ends in an error in state: 602.
##
## single_spec -> WRITES . LEFTBRC comma_list0(term) RIGHTBRC [ WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES RAISE QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## WRITES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL RANGE WRITES
##
## Ends in an error in state: 598.
##
## pdecl -> VAL top_ghost labels(lident_rich) . type_v [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL top_ghost labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE VAL WRITES
##
## Ends in an error in state: 594.
##
## pdecl -> VAL . top_ghost labels(lident_rich) type_v [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE UIDENT_QUOTE WITH
##
## Ends in an error in state: 593.
##
## theory_or_module -> module_head . list(module_decl) END [ THEORY MODULE EOF ]
##
## The known suffix of the stack is as follows:
## module_head
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production list(label) ->
## In state 7, spurious reduction of production labels(uident_nq) -> uident_nq list(label)
## In state 590, spurious reduction of production module_head -> MODULE labels(uident_nq)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: MODULE WRITES
##
## Ends in an error in state: 589.
##
## module_head -> MODULE . labels(uident_nq) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## MODULE
##

Error while parsing module name. An uident_nq was expected.

program_file: THEORY UIDENT END WRITES
##
## Ends in an error in state: 591.
##
## list(theory_or_module) -> theory_or_module . list(theory_or_module) [ EOF ]
##
## The known suffix of the stack is as follows:
## theory_or_module
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program_file: WRITES
##
## Ends in an error in state: 588.
##
## program_file' -> . program_file [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

open_file: WRITES
##
## Ends in an error in state: 585.
##
## open_file' -> . open_file [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE AXIOM UIDENT_QUOTE COLON UIDENT_QUOTE WITH
##
## Ends in an error in state: 570.
##
## decl -> AXIOM labels(ident_nq) COLON term . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## term_ -> term . ARROW term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## AXIOM labels(ident_nq) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE AXIOM UIDENT_QUOTE COLON WRITES
##
## Ends in an error in state: 569.
##
## decl -> AXIOM labels(ident_nq) COLON . term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM labels(ident_nq) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE AXIOM UIDENT_QUOTE STRING WRITES
##
## Ends in an error in state: 568.
##
## decl -> AXIOM labels(ident_nq) . COLON term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM labels(ident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 489, spurious reduction of production labels(ident_nq) -> ident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE AXIOM WRITES
##
## Ends in an error in state: 567.
##
## decl -> AXIOM . labels(ident_nq) COLON term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## AXIOM
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE EXPORT UIDENT AS
##
## Ends in an error in state: 529.
##
## use_clone -> CLONE use . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use_clone -> CLONE use . WITH comma_list1(clone_subst) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE use
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production tqualid -> UIDENT
## In state 23, spurious reduction of production use -> EXPORT tqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH CONSTANT UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 560.
##
## clone_subst -> CONSTANT qualid EQUAL . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT qualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH CONSTANT UIDENT_QUOTE WITH
##
## Ends in an error in state: 559.
##
## clone_subst -> CONSTANT qualid . EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT qualid
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH CONSTANT WRITES
##
## Ends in an error in state: 558.
##
## clone_subst -> CONSTANT . qualid EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH FUNCTION UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 556.
##
## clone_subst -> FUNCTION qualid EQUAL . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION qualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH FUNCTION UIDENT_QUOTE WITH
##
## Ends in an error in state: 555.
##
## clone_subst -> FUNCTION qualid . EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION qualid
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH FUNCTION WRITES
##
## Ends in an error in state: 554.
##
## clone_subst -> FUNCTION . qualid EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH GOAL WRITES
##
## Ends in an error in state: 552.
##
## clone_subst -> GOAL . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH LEMMA RANGE WRITES
##
## Ends in an error in state: 564.
##
## separated_nonempty_list(COMMA,clone_subst) -> clone_subst . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(COMMA,clone_subst) -> clone_subst . COMMA separated_nonempty_list(COMMA,clone_subst) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## clone_subst
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH LEMMA UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 565.
##
## separated_nonempty_list(COMMA,clone_subst) -> clone_subst COMMA . separated_nonempty_list(COMMA,clone_subst) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## clone_subst COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH LEMMA WRITES
##
## Ends in an error in state: 550.
##
## clone_subst -> LEMMA . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH NAMESPACE UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 548.
##
## clone_subst -> NAMESPACE ns EQUAL . ns [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## NAMESPACE ns EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH NAMESPACE UIDENT_QUOTE VAL
##
## Ends in an error in state: 547.
##
## clone_subst -> NAMESPACE ns . EQUAL ns [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## NAMESPACE ns
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 546, spurious reduction of production ns -> uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH NAMESPACE UIDENT_QUOTE WRITES
##
## Ends in an error in state: 546.
##
## ns -> uqualid . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## uqualid -> uqualid . DOT UIDENT [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END DOT CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END DOT CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH NAMESPACE WRITES
##
## Ends in an error in state: 544.
##
## clone_subst -> NAMESPACE . ns EQUAL ns [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## NAMESPACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH PREDICATE UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 542.
##
## clone_subst -> PREDICATE qualid EQUAL . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE qualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH PREDICATE UIDENT_QUOTE WITH
##
## Ends in an error in state: 541.
##
## clone_subst -> PREDICATE qualid . EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE qualid
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH PREDICATE WRITES
##
## Ends in an error in state: 540.
##
## clone_subst -> PREDICATE . qualid EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH TYPE UIDENT_QUOTE EQUAL RANGE WRITES
##
## Ends in an error in state: 539.
##
## clone_subst -> TYPE qualid list(ty_var) EQUAL ty . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## ty -> ty . ARROW ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## TYPE qualid list(ty_var) EQUAL ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH TYPE UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 538.
##
## clone_subst -> TYPE qualid list(ty_var) EQUAL . ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE qualid list(ty_var) EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH TYPE UIDENT_QUOTE QUOTE_LIDENT END
##
## Ends in an error in state: 537.
##
## clone_subst -> TYPE qualid list(ty_var) . EQUAL ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE qualid list(ty_var)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 52, spurious reduction of production list(label) ->
## In state 53, spurious reduction of production labels(quote_lident) -> quote_lident list(label)
## In state 55, spurious reduction of production ty_var -> labels(quote_lident)
## In state 51, spurious reduction of production list(ty_var) ->
## In state 54, spurious reduction of production list(ty_var) -> ty_var list(ty_var)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH TYPE UIDENT_QUOTE WITH
##
## Ends in an error in state: 536.
##
## clone_subst -> TYPE qualid . list(ty_var) EQUAL ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE qualid
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH TYPE WRITES
##
## Ends in an error in state: 535.
##
## clone_subst -> TYPE . qualid list(ty_var) EQUAL ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH VAL UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 533.
##
## clone_subst -> VAL qualid EQUAL . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL qualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH VAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 532.
##
## clone_subst -> VAL qualid . EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL qualid
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH VAL WRITES
##
## Ends in an error in state: 531.
##
## clone_subst -> VAL . qualid EQUAL qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## VAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 530.
##
## use_clone -> CLONE use WITH . comma_list1(clone_subst) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE use WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CLONE WRITES
##
## Ends in an error in state: 528.
##
## use_clone -> CLONE . use [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use_clone -> CLONE . use WITH comma_list1(clone_subst) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CLONE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE COINDUCTIVE WRITES
##
## Ends in an error in state: 526.
##
## decl -> COINDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## COINDUCTIVE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CONSTANT RANGE COLON FLOAT WRITES
##
## Ends in an error in state: 523.
##
## constant_decl -> labels(lident_rich) cast . option(preceded(EQUAL,term)) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich) cast
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CONSTANT RANGE COLON RANGE UNDERSCORE
##
## Ends in an error in state: 117.
##
## cast -> COLON ty . [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## ty -> ty . ARROW ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## COLON ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CONSTANT RANGE COLON WRITES
##
## Ends in an error in state: 116.
##
## cast -> COLON . ty [ WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CONSTANT RANGE WRITES
##
## Ends in an error in state: 522.
##
## constant_decl -> labels(lident_rich) . cast option(preceded(EQUAL,term)) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE CONSTANT WRITES
##
## Ends in an error in state: 521.
##
## decl -> CONSTANT . constant_decl [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE END WRITES
##
## Ends in an error in state: 580.
##
## list(theory) -> theory . list(theory) [ EOF ]
##
## The known suffix of the stack is as follows:
## theory
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE FUNCTION RANGE COLON FLOAT WRITES
##
## Ends in an error in state: 517.
##
## function_decl -> labels(lident_rich) params cast . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich) params cast
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE FUNCTION RANGE UNDERSCORE WRITES
##
## Ends in an error in state: 516.
##
## function_decl -> labels(lident_rich) params . cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich) params
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 418, spurious reduction of production list(param) ->
## In state 419, spurious reduction of production list(param) -> param list(param)
## In state 421, spurious reduction of production params -> list(param)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE FUNCTION RANGE WRITES
##
## Ends in an error in state: 515.
##
## function_decl -> labels(lident_rich) . params cast option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE FUNCTION WRITES
##
## Ends in an error in state: 514.
##
## decl -> FUNCTION . function_decl list(with_logic_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE GOAL UIDENT_QUOTE COLON UIDENT_QUOTE WITH
##
## Ends in an error in state: 513.
##
## decl -> GOAL labels(ident_nq) COLON term . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## term_ -> term . ARROW term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## GOAL labels(ident_nq) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE GOAL UIDENT_QUOTE COLON WRITES
##
## Ends in an error in state: 512.
##
## decl -> GOAL labels(ident_nq) COLON . term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL labels(ident_nq) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE GOAL UIDENT_QUOTE STRING WRITES
##
## Ends in an error in state: 511.
##
## decl -> GOAL labels(ident_nq) . COLON term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL labels(ident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 489, spurious reduction of production labels(ident_nq) -> ident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE GOAL WRITES
##
## Ends in an error in state: 510.
##
## decl -> GOAL . labels(ident_nq) COLON term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## GOAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE EQUAL BAR WRITES
##
## Ends in an error in state: 496.
##
## bar_list1(ind_case) -> BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE EQUAL UIDENT_QUOTE COLON EPSILON BAR WRITES
##
## Ends in an error in state: 502.
##
## separated_nonempty_list(BAR,ind_case) -> ind_case BAR . separated_nonempty_list(BAR,ind_case) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ind_case BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE EQUAL UIDENT_QUOTE COLON UIDENT_QUOTE THEN
##
## Ends in an error in state: 500.
##
## ind_case -> labels(ident_nq) COLON term . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## term_ -> term . ARROW term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## labels(ident_nq) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE EQUAL UIDENT_QUOTE COLON WRITES
##
## Ends in an error in state: 499.
##
## ind_case -> labels(ident_nq) COLON . term [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(ident_nq) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE EQUAL UIDENT_QUOTE STRING WRITES
##
## Ends in an error in state: 498.
##
## ind_case -> labels(ident_nq) . COLON term [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(ident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 489, spurious reduction of production labels(ident_nq) -> ident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE EQUAL WRITES
##
## Ends in an error in state: 495.
##
## ind_defn -> EQUAL . bar_list1(ind_case) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE UNDERSCORE WRITES
##
## Ends in an error in state: 494.
##
## inductive_decl -> labels(lident_rich) params . ind_defn [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich) params
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 418, spurious reduction of production list(param) ->
## In state 419, spurious reduction of production list(param) -> param list(param)
## In state 421, spurious reduction of production params -> list(param)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE WITH WRITES
##
## Ends in an error in state: 508.
##
## separated_nonempty_list(WITH,inductive_decl) -> inductive_decl WITH . separated_nonempty_list(WITH,inductive_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## inductive_decl WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE RANGE WRITES
##
## Ends in an error in state: 493.
##
## inductive_decl -> labels(lident_rich) . params ind_defn [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE INDUCTIVE WRITES
##
## Ends in an error in state: 490.
##
## decl -> INDUCTIVE . with_list1(inductive_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## INDUCTIVE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON IF UIDENT_QUOTE THEN UIDENT_QUOTE ELSE EPSILON WRITES
##
## Ends in an error in state: 339.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> IF term THEN term ELSE term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN term ELSE term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON IF UIDENT_QUOTE THEN UIDENT_QUOTE ELSE WRITES
##
## Ends in an error in state: 338.
##
## term_ -> IF term THEN term ELSE . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN term ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON IF UIDENT_QUOTE THEN UIDENT_QUOTE WITH
##
## Ends in an error in state: 337.
##
## term_ -> term . ARROW term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> IF term THEN term . ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL ELSE COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON IF UIDENT_QUOTE THEN WRITES
##
## Ends in an error in state: 336.
##
## term_ -> IF term THEN . term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term THEN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON IF UIDENT_QUOTE WITH
##
## Ends in an error in state: 335.
##
## term_ -> term . ARROW term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> IF term . THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ THEN SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON IF WRITES
##
## Ends in an error in state: 234.
##
## term_ -> IF . term THEN term ELSE term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE COLON FLOAT WRITES
##
## Ends in an error in state: 258.
##
## separated_nonempty_list(COMMA,quant_vars) -> quant_vars . [ LEFTSQ DOT ]
## separated_nonempty_list(COMMA,quant_vars) -> quant_vars . COMMA separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## quant_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
## In state 263, spurious reduction of production option(cast) -> cast
## In state 262, spurious reduction of production quant_vars -> nonempty_list(binder_var) option(cast)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE COMMA WRITES
##
## Ends in an error in state: 259.
##
## separated_nonempty_list(COMMA,quant_vars) -> quant_vars COMMA . separated_nonempty_list(COMMA,quant_vars) [ LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## quant_vars COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE DOT EPSILON WRITES
##
## Ends in an error in state: 320.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> quant comma_list1(quant_vars) triggers DOT term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant comma_list1(quant_vars) triggers DOT term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE DOT WRITES
##
## Ends in an error in state: 319.
##
## term_ -> quant comma_list1(quant_vars) triggers DOT . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant comma_list1(quant_vars) triggers DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE LEFTSQ UIDENT_QUOTE BAR WRITES
##
## Ends in an error in state: 316.
##
## separated_nonempty_list(BAR,comma_list1(term)) -> comma_list1(term) BAR . separated_nonempty_list(BAR,comma_list1(term)) [ RIGHTSQ ]
##
## The known suffix of the stack is as follows:
## comma_list1(term) BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE LEFTSQ UIDENT_QUOTE RIGHTSQ DONE
##
## Ends in an error in state: 318.
##
## term_ -> quant comma_list1(quant_vars) triggers . DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant comma_list1(quant_vars) triggers
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE LEFTSQ UIDENT_QUOTE WITH
##
## Ends in an error in state: 315.
##
## separated_nonempty_list(BAR,comma_list1(term)) -> comma_list1(term) . [ RIGHTSQ ]
## separated_nonempty_list(BAR,comma_list1(term)) -> comma_list1(term) . BAR separated_nonempty_list(BAR,comma_list1(term)) [ RIGHTSQ ]
##
## The known suffix of the stack is as follows:
## comma_list1(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
## In state 270, spurious reduction of production separated_nonempty_list(COMMA,term) -> term
## In state 312, spurious reduction of production comma_list1(term) -> separated_nonempty_list(COMMA,term)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE LEFTSQ WRITES
##
## Ends in an error in state: 269.
##
## triggers -> LEFTSQ . separated_nonempty_list(BAR,comma_list1(term)) RIGHTSQ [ DOT ]
##
## The known suffix of the stack is as follows:
## LEFTSQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA UNDERSCORE WRITES
##
## Ends in an error in state: 265.
##
## nonempty_list(binder_var) -> binder_var . [ LEFTSQ DOT COMMA COLON ]
## nonempty_list(binder_var) -> binder_var . nonempty_list(binder_var) [ LEFTSQ DOT COMMA COLON ]
##
## The known suffix of the stack is as follows:
## binder_var
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LAMBDA WRITES
##
## Ends in an error in state: 255.
##
## term_ -> quant . comma_list1(quant_vars) triggers DOT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## quant
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC RANGE EQUAL UIDENT_QUOTE SEMICOLON WRITES
##
## Ends in an error in state: 364.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL term SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC RANGE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 363.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL term . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
## term_ -> term . ARROW term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO SEMICOLON RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC RANGE EQUAL WRITES
##
## Ends in an error in state: 184.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid EQUAL . term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC RANGE WRITES
##
## Ends in an error in state: 369.
##
## lqualid -> lident . [ EQUAL DOT ]
## qualid -> lident . [ WITH LEFTSQ ]
##
## The known suffix of the stack is as follows:
## lident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC UIDENT_QUOTE DOT RANGE WRITES
##
## Ends in an error in state: 167.
##
## lqualid -> uqualid DOT lident . [ EQUAL DOT ]
## qualid -> uqualid DOT lident . [ WITH LEFTSQ ]
##
## The known suffix of the stack is as follows:
## uqualid DOT lident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 137.
##
## lqualid -> uqualid DOT . lident [ EQUAL DOT ]
## qualid -> uqualid DOT . UIDENT [ WITH LEFTSQ ]
## qualid -> uqualid DOT . UIDENT_QUOTE [ WITH LEFTSQ ]
## qualid -> uqualid DOT . lident [ WITH LEFTSQ ]
## qualid -> uqualid DOT . lident_op_id [ WITH LEFTSQ ]
## uqualid -> uqualid DOT . UIDENT [ DOT ]
## uqualid -> uqualid DOT . UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC UIDENT_QUOTE VAL
##
## Ends in an error in state: 180.
##
## term_sub_ -> LEFTBRC term_arg . WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ term LARROW term RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT term RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT RIGHTSQ [ WITH LEFTSQ DOT ]
## term_sub_ -> term_arg . LEFTSQ DOTDOT term RIGHTSQ [ WITH LEFTSQ DOT ]
##
## The known suffix of the stack is as follows:
## LEFTBRC term_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 179, spurious reduction of production mk_term(term_arg_) -> term_arg_
## In state 279, spurious reduction of production term_arg -> mk_term(term_arg_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC UIDENT_QUOTE WITH RANGE WRITES
##
## Ends in an error in state: 183.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,term)) -> lqualid . EQUAL term SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,term)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 181.
##
## term_sub_ -> LEFTBRC term_arg WITH . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTBRC term_arg WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTBRC WRITES
##
## Ends in an error in state: 133.
##
## term_sub_ -> LEFTBRC . field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> LEFTBRC . term_arg WITH field_list1(term) RIGHTBRC [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTPAR OP4 WRITES
##
## Ends in an error in state: 376.
##
## lident_op -> op_symbol . [ RIGHTPAR ]
## lident_op -> op_symbol . UNDERSCORE [ RIGHTPAR ]
## prefix_op -> op_symbol . [ WHILE VAL UIDENT_QUOTE UIDENT TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT POSITION OPPREF OP4 OP3 OP2 OP1 NOT MODEL MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LAMBDA INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EPSILON CHECK BEGIN ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## op_symbol
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTPAR OPPREF WRITES
##
## Ends in an error in state: 132.
##
## lident_op -> OPPREF . [ RIGHTPAR ]
## term_arg_ -> OPPREF . term_arg [ UIDENT_QUOTE UIDENT TRUE SO RIGHTPAR REAL RANGE QUOTE_UIDENT OR OPPREF OP4 OP3 OP2 OP1 MODEL LTGT LT LRARROW LIDENT_QUOTE LIDENT LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER GT FLOAT FALSE EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_dot_ -> OPPREF . term_dot [ DOT ]
##
## The known suffix of the stack is as follows:
## OPPREF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTPAR RIGHTPAR WRITES
##
## Ends in an error in state: 168.
##
## term_arg_ -> term_sub_ . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_dot_ -> term_sub_ . [ DOT ]
##
## The known suffix of the stack is as follows:
## term_sub_
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTPAR UIDENT_QUOTE COMMA EPSILON WITH
##
## Ends in an error in state: 377.
##
## term_sub_ -> LEFTPAR comma_list2(term) . RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR comma_list2(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 270, spurious reduction of production separated_nonempty_list(COMMA,term) -> term
## In state 312, spurious reduction of production comma_list1(term) -> separated_nonempty_list(COMMA,term)
## In state 357, spurious reduction of production comma_list2(term) -> term COMMA comma_list1(term)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTPAR UIDENT_QUOTE WITH
##
## Ends in an error in state: 374.
##
## comma_list2(term) -> term . COMMA comma_list1(term) [ RIGHTPAR ]
## term_ -> term . ARROW term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTPAR OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_sub_ -> LEFTPAR term . RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LEFTPAR WRITES
##
## Ends in an error in state: 130.
##
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> LEFTPAR . term RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> LEFTPAR . RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> LEFTPAR . comma_list2(term) RIGHTPAR [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTBRC RANGE EQUAL UNDERSCORE RIGHTPAR
##
## Ends in an error in state: 205.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern . SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production pat_conj_ -> pat_uni_
## In state 209, spurious reduction of production pattern_ -> pat_conj_
## In state 204, spurious reduction of production mk_pat(pattern_) -> pattern_
## In state 211, spurious reduction of production pattern -> mk_pat(pattern_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTBRC RANGE EQUAL UNDERSCORE SEMICOLON WRITES
##
## Ends in an error in state: 206.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL pattern SEMICOLON . semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL pattern SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTBRC RANGE EQUAL WRITES
##
## Ends in an error in state: 194.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid EQUAL . pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTBRC RANGE WRITES
##
## Ends in an error in state: 193.
##
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON [ RIGHTBRC ]
## semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) -> lqualid . EQUAL pattern SEMICOLON semicolon_list1(separated_pair(lqualid,EQUAL,pattern)) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## lqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTBRC WRITES
##
## Ends in an error in state: 191.
##
## pat_arg_ -> LEFTBRC . field_list1(pattern) RIGHTBRC [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTPAR UNDERSCORE SEMICOLON
##
## Ends in an error in state: 229.
##
## pat_arg_ -> LEFTPAR pattern_ . RIGHTPAR [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR pattern_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production pat_conj_ -> pat_uni_
## In state 209, spurious reduction of production pattern_ -> pat_conj_
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET LEFTPAR WRITES
##
## Ends in an error in state: 189.
##
## pat_arg_ -> LEFTPAR . RIGHTPAR [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL COMMA COLON BAR AS ARROW ]
## pat_arg_ -> LEFTPAR . pattern_ RIGHTPAR [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 196.
##
## uqualid -> uqualid DOT . UIDENT [ WITH WHILE VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE RAISE QUOTE_UIDENT PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT AS ARROW ANY AMPAMP ABSURD ABSTRACT ]
## uqualid -> uqualid DOT . UIDENT_QUOTE [ WITH WHILE VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRY TRUE TO THEN STRING SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE RAISE QUOTE_UIDENT PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LTGT LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BEGIN BARBAR BAR AXIOM ASSUME ASSERT AS ARROW ANY AMPAMP ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UIDENT_QUOTE UIDENT_QUOTE WRITES
##
## Ends in an error in state: 197.
##
## pat_arg_ -> uqualid . [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL COMMA COLON BAR AS ARROW ]
## uqualid -> uqualid . DOT UIDENT [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT COMMA COLON BAR AS ARROW ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UIDENT_QUOTE UNDERSCORE WRITES
##
## Ends in an error in state: 199.
##
## nonempty_list(pat_arg) -> pat_arg . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## nonempty_list(pat_arg) -> pat_arg . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## pat_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UIDENT_QUOTE WRITES
##
## Ends in an error in state: 195.
##
## pat_arg_ -> uqualid . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## pat_uni_ -> uqualid . nonempty_list(pat_arg) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## uqualid -> uqualid . DOT UIDENT [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT COMMA COLON BAR AS ARROW ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ UNDERSCORE UIDENT_QUOTE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL DOT COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE AS WRITES
##
## Ends in an error in state: 219.
##
## pat_uni_ -> mk_pat(pat_uni_) AS . labels(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE BAR WRITES
##
## Ends in an error in state: 224.
##
## pattern_ -> mk_pat(pat_conj_) BAR . pattern [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_conj_) BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE COMMA UNDERSCORE COMMA WRITES
##
## Ends in an error in state: 217.
##
## separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE COMMA UNDERSCORE WRITES
##
## Ends in an error in state: 216.
##
## pat_uni_ -> mk_pat(pat_uni_) . AS labels(lident_nq) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## pat_uni_ -> mk_pat(pat_uni_) . cast [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW ]
## separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
## separated_nonempty_list(COMMA,mk_pat(pat_uni_)) -> mk_pat(pat_uni_) . COMMA separated_nonempty_list(COMMA,mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE COMMA WRITES
##
## Ends in an error in state: 213.
##
## comma_list2(mk_pat(pat_uni_)) -> mk_pat(pat_uni_) COMMA . comma_list1(mk_pat(pat_uni_)) [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## mk_pat(pat_uni_) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE EQUAL UIDENT_QUOTE IN EPSILON WRITES
##
## Ends in an error in state: 342.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> LET pattern EQUAL term IN term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL term IN term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE EQUAL UIDENT_QUOTE IN WRITES
##
## Ends in an error in state: 341.
##
## term_ -> LET pattern EQUAL term IN . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL term IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE EQUAL UIDENT_QUOTE WITH
##
## Ends in an error in state: 340.
##
## term_ -> term . ARROW term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> LET pattern EQUAL term . IN term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW IN GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE EQUAL WRITES
##
## Ends in an error in state: 232.
##
## term_ -> LET pattern EQUAL . term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE SEMICOLON
##
## Ends in an error in state: 231.
##
## term_ -> LET pattern . EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 208, spurious reduction of production pat_conj_ -> pat_uni_
## In state 209, spurious reduction of production pattern_ -> pat_conj_
## In state 204, spurious reduction of production mk_pat(pattern_) -> pattern_
## In state 211, spurious reduction of production pattern -> mk_pat(pattern_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET UNDERSCORE WRITES
##
## Ends in an error in state: 208.
##
## mk_pat(pat_uni_) -> pat_uni_ . [ COMMA COLON AS ]
## pat_conj_ -> pat_uni_ . [ SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW ]
##
## The known suffix of the stack is as follows:
## pat_uni_
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON LET WRITES
##
## Ends in an error in state: 187.
##
## term_ -> LET . pattern EQUAL term IN term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LET
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE COMMA EPSILON RIGHTSQ
##
## Ends in an error in state: 358.
##
## term_ -> MATCH comma_list2(term) . WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH comma_list2(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 270, spurious reduction of production separated_nonempty_list(COMMA,term) -> term
## In state 312, spurious reduction of production comma_list1(term) -> separated_nonempty_list(COMMA,term)
## In state 357, spurious reduction of production comma_list2(term) -> term COMMA comma_list1(term)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE COMMA EPSILON WITH UNDERSCORE ARROW EPSILON RIGHTBRC
##
## Ends in an error in state: 360.
##
## term_ -> MATCH comma_list2(term) WITH match_cases(term) . END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH comma_list2(term) WITH match_cases(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 349, spurious reduction of production separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW term
## In state 352, spurious reduction of production bar_list1(separated_pair(pattern,ARROW,term)) -> separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))
## In state 355, spurious reduction of production match_cases(term) -> bar_list1(separated_pair(pattern,ARROW,term))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE COMMA EPSILON WITH WRITES
##
## Ends in an error in state: 359.
##
## term_ -> MATCH comma_list2(term) WITH . match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH comma_list2(term) WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE COMMA WRITES
##
## Ends in an error in state: 356.
##
## comma_list2(term) -> term COMMA . comma_list1(term) [ WITH RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## term COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE VAL
##
## Ends in an error in state: 343.
##
## comma_list2(term) -> term . COMMA comma_list1(term) [ WITH ]
## term_ -> term . ARROW term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> MATCH term . WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH SO OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COMMA COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE WITH UNDERSCORE ARROW EPSILON RIGHTBRC
##
## Ends in an error in state: 353.
##
## term_ -> MATCH term WITH match_cases(term) . END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH term WITH match_cases(term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 349, spurious reduction of production separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term)) -> pattern ARROW term
## In state 352, spurious reduction of production bar_list1(separated_pair(pattern,ARROW,term)) -> separated_nonempty_list(BAR,separated_pair(pattern,ARROW,term))
## In state 355, spurious reduction of production match_cases(term) -> bar_list1(separated_pair(pattern,ARROW,term))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH UIDENT_QUOTE WITH WRITES
##
## Ends in an error in state: 344.
##
## term_ -> MATCH term WITH . match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH term WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON MATCH WRITES
##
## Ends in an error in state: 186.
##
## term_ -> MATCH . term WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> MATCH . comma_list2(term) WITH match_cases(term) END [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## MATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON NOT EPSILON WRITES
##
## Ends in an error in state: 362.
##
## term_ -> NOT term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## NOT term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON NOT WRITES
##
## Ends in an error in state: 185.
##
## term_ -> NOT . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## NOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON OP4 WRITES
##
## Ends in an error in state: 274.
##
## term_ -> prefix_op . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## prefix_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON OPPREF WRITES
##
## Ends in an error in state: 128.
##
## term_arg_ -> OPPREF . term_arg [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_dot_ -> OPPREF . term_dot [ DOT ]
##
## The known suffix of the stack is as follows:
## OPPREF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON RANGE DOT UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 173.
##
## lqualid_rich -> uqualid DOT . lident [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## lqualid_rich -> uqualid DOT . lident_op_id [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> uqualid DOT . UIDENT [ DOT ]
## uqualid -> uqualid DOT . UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON RANGE DOT UIDENT_QUOTE WRITES
##
## Ends in an error in state: 172.
##
## lqualid_rich -> uqualid . DOT lident [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## lqualid_rich -> uqualid . DOT lident_op_id [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> uqualid . DOT UIDENT [ DOT ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON RANGE DOT WRITES
##
## Ends in an error in state: 171.
##
## term_sub_ -> term_dot DOT . lqualid_rich [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_dot DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON RANGE WRITES
##
## Ends in an error in state: 283.
##
## lqualid -> lident . [ DOT ]
## qualid -> lident . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## lident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON STRING EPSILON WRITES
##
## Ends in an error in state: 285.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> label term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## label term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON STRING WRITES
##
## Ends in an error in state: 284.
##
## term_ -> label . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## label
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE AMPAMP EPSILON WRITES
##
## Ends in an error in state: 307.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term AMPAMP term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term AMPAMP term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE AMPAMP WRITES
##
## Ends in an error in state: 306.
##
## term_ -> term AMPAMP . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term AMPAMP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE AND EPSILON WRITES
##
## Ends in an error in state: 305.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term AND term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term AND term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE AND WRITES
##
## Ends in an error in state: 304.
##
## term_ -> term AND . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE ARROW EPSILON WRITES
##
## Ends in an error in state: 309.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term ARROW term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term ARROW term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE ARROW WRITES
##
## Ends in an error in state: 308.
##
## term_ -> term ARROW . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE BARBAR EPSILON WRITES
##
## Ends in an error in state: 303.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term BARBAR term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term BARBAR term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE BARBAR WRITES
##
## Ends in an error in state: 302.
##
## term_ -> term BARBAR . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term BARBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE BY EPSILON WRITES
##
## Ends in an error in state: 301.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term BY term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term BY term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE BY WRITES
##
## Ends in an error in state: 300.
##
## term_ -> term BY . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term BY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE DOT RANGE WRITES
##
## Ends in an error in state: 240.
##
## lqualid -> uqualid DOT lident . [ DOT ]
## qualid -> uqualid DOT lident . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## uqualid DOT lident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 239.
##
## lqualid -> uqualid DOT . lident [ DOT ]
## qualid -> uqualid DOT . UIDENT [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## qualid -> uqualid DOT . UIDENT_QUOTE [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## qualid -> uqualid DOT . lident [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## qualid -> uqualid DOT . lident_op_id [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> uqualid DOT . UIDENT [ DOT ]
## uqualid -> uqualid DOT . UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE EQUAL EPSILON WRITES
##
## Ends in an error in state: 299.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term EQUAL term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term EQUAL term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE EQUAL WRITES
##
## Ends in an error in state: 298.
##
## term_ -> term EQUAL . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE GT EPSILON WRITES
##
## Ends in an error in state: 297.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term GT term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term GT term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE GT WRITES
##
## Ends in an error in state: 296.
##
## term_ -> term GT . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term GT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ DOTDOT UIDENT_QUOTE WITH
##
## Ends in an error in state: 246.
##
## term_ -> term . ARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ DOTDOT term . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ DOTDOT term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ DOTDOT WRITES
##
## Ends in an error in state: 244.
##
## term_sub_ -> term_arg LEFTSQ DOTDOT . term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ DOTDOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ UIDENT_QUOTE DOTDOT UIDENT_QUOTE WITH
##
## Ends in an error in state: 329.
##
## term_ -> term . ARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term DOTDOT term . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term DOTDOT term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ UIDENT_QUOTE DOTDOT WRITES
##
## Ends in an error in state: 327.
##
## term_sub_ -> term_arg LEFTSQ term DOTDOT . term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term DOTDOT . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term DOTDOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ UIDENT_QUOTE LARROW UIDENT_QUOTE WITH
##
## Ends in an error in state: 325.
##
## term_ -> term . ARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term LARROW term . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term LARROW term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ UIDENT_QUOTE LARROW WRITES
##
## Ends in an error in state: 324.
##
## term_sub_ -> term_arg LEFTSQ term LARROW . term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term LARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ UIDENT_QUOTE WITH
##
## Ends in an error in state: 322.
##
## term_ -> term . ARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTSQ OR OP4 OP3 OP2 OP1 LTGT LT LRARROW LARROW GT EQUAL DOTDOT COLON BY BARBAR ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . LARROW term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ term . DOTDOT RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LEFTSQ WRITES
##
## Ends in an error in state: 243.
##
## term_sub_ -> term_arg LEFTSQ . term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . term LARROW term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . term DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . term DOTDOT RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg LEFTSQ . DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg LEFTSQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LRARROW EPSILON WRITES
##
## Ends in an error in state: 295.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term LRARROW term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term LRARROW term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LRARROW WRITES
##
## Ends in an error in state: 294.
##
## term_ -> term LRARROW . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term LRARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LT EPSILON WRITES
##
## Ends in an error in state: 293.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term LT term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term LT term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LT WRITES
##
## Ends in an error in state: 292.
##
## term_ -> term LT . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LTGT EPSILON WRITES
##
## Ends in an error in state: 291.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term LTGT term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term LTGT term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE LTGT WRITES
##
## Ends in an error in state: 290.
##
## term_ -> term LTGT . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term LTGT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP1 EPSILON WRITES
##
## Ends in an error in state: 289.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term OP1 term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP1 term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP1 WRITES
##
## Ends in an error in state: 288.
##
## term_ -> term OP1 . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP1
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP2 EPSILON WRITES
##
## Ends in an error in state: 287.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term OP2 term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP2 term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP2 WRITES
##
## Ends in an error in state: 286.
##
## term_ -> term OP2 . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP2
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP3 EPSILON WRITES
##
## Ends in an error in state: 272.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term OP3 term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP3 term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP3 WRITES
##
## Ends in an error in state: 271.
##
## term_ -> term OP3 . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP3
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OP4 WRITES
##
## Ends in an error in state: 251.
##
## term_ -> term OP4 . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OP4
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OR EPSILON WRITES
##
## Ends in an error in state: 250.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term OR term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OR term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE OR WRITES
##
## Ends in an error in state: 249.
##
## term_ -> term OR . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE SO EPSILON WRITES
##
## Ends in an error in state: 248.
##
## term_ -> term . ARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term SO term . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term SO term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE SO WRITES
##
## Ends in an error in state: 247.
##
## term_ -> term SO . term [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term SO
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE TO
##
## Ends in an error in state: 241.
##
## mk_term(term_arg_) -> term_arg_ . [ UIDENT_QUOTE UIDENT TRUE REAL RANGE QUOTE_UIDENT OPPREF MODEL LIDENT_QUOTE LIDENT LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER FLOAT FALSE ]
## term_ -> term_arg_ . [ WITH VAL USE TYPE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN GT GOAL FUNCTION EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE UIDENT_QUOTE TO
##
## Ends in an error in state: 331.
##
## located(term_arg) -> term_arg . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term LARROW term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ term DOTDOT RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
## term_sub_ -> term_arg . LEFTSQ DOTDOT term RIGHTSQ [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOTDOT DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## term_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 179, spurious reduction of production mk_term(term_arg_) -> term_arg_
## In state 279, spurious reduction of production term_arg -> mk_term(term_arg_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON UIDENT_QUOTE WITH
##
## Ends in an error in state: 487.
##
## decl -> LEMMA labels(ident_nq) COLON term . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## term_ -> term . ARROW term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEMMA labels(ident_nq) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE COLON WRITES
##
## Ends in an error in state: 486.
##
## decl -> LEMMA labels(ident_nq) COLON . term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA labels(ident_nq) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE POSITION WRITES
##
## Ends in an error in state: 485.
##
## decl -> LEMMA labels(ident_nq) . COLON term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA labels(ident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 489, spurious reduction of production labels(ident_nq) -> ident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA UIDENT_QUOTE WRITES
##
## Ends in an error in state: 488.
##
## labels(ident_nq) -> ident_nq . list(label) [ COLON ]
##
## The known suffix of the stack is as follows:
## ident_nq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE LEMMA WRITES
##
## Ends in an error in state: 482.
##
## decl -> LEMMA . labels(ident_nq) COLON term [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## LEMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE CONSTANT WRITES
##
## Ends in an error in state: 475.
##
## meta_arg -> CONSTANT . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## CONSTANT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE FUNCTION WRITES
##
## Ends in an error in state: 473.
##
## meta_arg -> FUNCTION . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## FUNCTION
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PREDICATE WRITES
##
## Ends in an error in state: 470.
##
## meta_arg -> PREDICATE . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PROP UIDENT WRITES
##
## Ends in an error in state: 124.
##
## qualid -> UIDENT . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT QUOTE_LIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> UIDENT . [ DOT ]
##
## The known suffix of the stack is as follows:
## UIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PROP UIDENT_QUOTE DOT UIDENT WRITES
##
## Ends in an error in state: 139.
##
## qualid -> uqualid DOT UIDENT . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT QUOTE_LIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> uqualid DOT UIDENT . [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT UIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PROP UIDENT_QUOTE DOT UIDENT_QUOTE WRITES
##
## Ends in an error in state: 138.
##
## qualid -> uqualid DOT UIDENT_QUOTE . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT QUOTE_LIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> uqualid DOT UIDENT_QUOTE . [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PROP UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 466.
##
## qualid -> uqualid DOT . UIDENT [ VAL USE TYPE QUOTE_LIDENT PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## qualid -> uqualid DOT . UIDENT_QUOTE [ VAL USE TYPE QUOTE_LIDENT PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## qualid -> uqualid DOT . lident [ VAL USE TYPE QUOTE_LIDENT PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## qualid -> uqualid DOT . lident_op_id [ VAL USE TYPE QUOTE_LIDENT PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## uqualid -> uqualid DOT . UIDENT [ DOT ]
## uqualid -> uqualid DOT . UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PROP UIDENT_QUOTE WRITES
##
## Ends in an error in state: 123.
##
## qualid -> UIDENT_QUOTE . [ WITH VAL USE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE QUOTE_UIDENT QUOTE_LIDENT PREDICATE OR OPPREF OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL END ELSE DOWNTO DOTDOT DONE DO CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
## uqualid -> UIDENT_QUOTE . [ DOT ]
##
## The known suffix of the stack is as follows:
## UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE PROP WRITES
##
## Ends in an error in state: 464.
##
## meta_arg -> PROP . qualid [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PROP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE STRING COMMA WRITES
##
## Ends in an error in state: 479.
##
## separated_nonempty_list(COMMA,meta_arg) -> meta_arg COMMA . separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## meta_arg COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE STRING WRITES
##
## Ends in an error in state: 478.
##
## separated_nonempty_list(COMMA,meta_arg) -> meta_arg . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(COMMA,meta_arg) -> meta_arg . COMMA separated_nonempty_list(COMMA,meta_arg) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## meta_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE TYPE RANGE WRITES
##
## Ends in an error in state: 462.
##
## meta_arg -> TYPE ty . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
## ty -> ty . ARROW ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## TYPE ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE TYPE WRITES
##
## Ends in an error in state: 461.
##
## meta_arg -> TYPE . ty [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COMMA COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META UIDENT_QUOTE WRITES
##
## Ends in an error in state: 460.
##
## decl -> META sident . comma_list1(meta_arg) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## META sident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE META WRITES
##
## Ends in an error in state: 457.
##
## decl -> META . sident comma_list1(meta_arg) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## META
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE NAMESPACE IMPORT WRITES
##
## Ends in an error in state: 455.
##
## namespace_head -> NAMESPACE boption(IMPORT) . uident_nq [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## NAMESPACE boption(IMPORT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE NAMESPACE UIDENT WRITES
##
## Ends in an error in state: 573.
##
## theory_decl -> namespace_head . list(theory_decl) END [ USE TYPE PREDICATE NAMESPACE META LEMMA INDUCTIVE GOAL FUNCTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## namespace_head
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE NAMESPACE WRITES
##
## Ends in an error in state: 454.
##
## namespace_head -> NAMESPACE . boption(IMPORT) uident_nq [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## NAMESPACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ DOTDOT UNDERSCORE WRITES
##
## Ends in an error in state: 158.
##
## lident_op -> LEFTSQ DOTDOT UNDERSCORE . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ DOTDOT UNDERSCORE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ DOTDOT WRITES
##
## Ends in an error in state: 157.
##
## lident_op -> LEFTSQ DOTDOT . UNDERSCORE RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ DOTDOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ LARROW WRITES
##
## Ends in an error in state: 155.
##
## lident_op -> LEFTSQ LARROW . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ LARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ RIGHTSQ WRITES
##
## Ends in an error in state: 153.
##
## lident_op -> LEFTSQ RIGHTSQ . [ RIGHTPAR ]
## lident_op -> LEFTSQ RIGHTSQ . LARROW [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ RIGHTSQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ UNDERSCORE DOTDOT UNDERSCORE WRITES
##
## Ends in an error in state: 150.
##
## lident_op -> LEFTSQ UNDERSCORE DOTDOT UNDERSCORE . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ UNDERSCORE DOTDOT UNDERSCORE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ UNDERSCORE DOTDOT WRITES
##
## Ends in an error in state: 149.
##
## lident_op -> LEFTSQ UNDERSCORE DOTDOT . UNDERSCORE RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ UNDERSCORE DOTDOT . RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ UNDERSCORE DOTDOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ UNDERSCORE WRITES
##
## Ends in an error in state: 148.
##
## lident_op -> LEFTSQ UNDERSCORE . DOTDOT UNDERSCORE RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ UNDERSCORE . DOTDOT RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ UNDERSCORE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR LEFTSQ WRITES
##
## Ends in an error in state: 147.
##
## lident_op -> LEFTSQ . RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . LARROW RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . RIGHTSQ LARROW [ RIGHTPAR ]
## lident_op -> LEFTSQ . UNDERSCORE DOTDOT UNDERSCORE RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . DOTDOT UNDERSCORE RIGHTSQ [ RIGHTPAR ]
## lident_op -> LEFTSQ . UNDERSCORE DOTDOT RIGHTSQ [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## LEFTSQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR OP4 WRITES
##
## Ends in an error in state: 162.
##
## lident_op -> op_symbol . [ RIGHTPAR ]
## lident_op -> op_symbol . UNDERSCORE [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## op_symbol
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR OPPREF WRITES
##
## Ends in an error in state: 164.
##
## lident_op_id -> LEFTPAR lident_op . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OR OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR lident_op
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE LEFTPAR WRITES
##
## Ends in an error in state: 140.
##
## lident_op_id -> LEFTPAR . lident_op RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_UIDENT QUOTE_LIDENT PREDICATE POSITION OR OPPREF OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE EQUAL UIDENT_QUOTE THEN
##
## Ends in an error in state: 446.
##
## option(preceded(EQUAL,term)) -> EQUAL term . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## term_ -> term . ARROW term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OR term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AND term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . BY term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . SO term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . LT term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . GT term [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
## term_ -> term . cast [ WITH VAL USE TYPE SO PREDICATE OR OP4 OP3 OP2 OP1 NAMESPACE META LTGT LT LRARROW LET LEMMA INDUCTIVE GT GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COLON COINDUCTIVE CLONE BY BARBAR AXIOM ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## EQUAL term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE EQUAL WRITES
##
## Ends in an error in state: 445.
##
## option(preceded(EQUAL,term)) -> EQUAL . term [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR GHOST RANGE WRITES
##
## Ends in an error in state: 391.
##
## binder_vars_head -> ty . [ UNDERSCORE STRING POSITION COLON ]
## param -> LEFTPAR GHOST ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## ty -> ty . ARROW ty [ UNDERSCORE STRING RIGHTPAR POSITION COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR GHOST UNDERSCORE COLON FLOAT WRITES
##
## Ends in an error in state: 404.
##
## param -> LEFTPAR GHOST binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST binder_vars cast
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR GHOST WRITES
##
## Ends in an error in state: 390.
##
## param -> LEFTPAR GHOST . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> LEFTPAR GHOST . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> LEFTPAR GHOST . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## LEFTPAR GHOST
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE COMMA RANGE COMMA WRITES
##
## Ends in an error in state: 90.
##
## separated_nonempty_list(COMMA,ty) -> ty COMMA . separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## ty COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE COMMA RANGE WRITES
##
## Ends in an error in state: 89.
##
## separated_nonempty_list(COMMA,ty) -> ty . [ RIGHTPAR ]
## separated_nonempty_list(COMMA,ty) -> ty . COMMA separated_nonempty_list(COMMA,ty) [ RIGHTPAR ]
## ty -> ty . ARROW ty [ RIGHTPAR COMMA ARROW ]
##
## The known suffix of the stack is as follows:
## ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE COMMA WRITES
##
## Ends in an error in state: 88.
##
## comma_list2(ty) -> ty COMMA . comma_list1(ty) [ RIGHTPAR ]
##
## The known suffix of the stack is as follows:
## ty COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE STRING STRING COINDUCTIVE
##
## Ends in an error in state: 397.
##
## binder_vars_rest -> binder_vars_head label list(label) . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_vars_head label list(label)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE STRING WRITES
##
## Ends in an error in state: 396.
##
## binder_vars_rest -> binder_vars_head label . list(label) list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_vars_head label
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE UNDERSCORE WRITES
##
## Ends in an error in state: 401.
##
## binder_vars_rest -> binder_vars_head anon_binder . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_vars_head anon_binder
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR RANGE WRITES
##
## Ends in an error in state: 408.
##
## binder_vars_head -> ty . [ UNDERSCORE STRING POSITION COLON ]
## comma_list2(ty) -> ty . COMMA comma_list1(ty) [ RIGHTPAR ]
## ty -> ty . ARROW ty [ UNDERSCORE STRING RIGHTPAR POSITION COMMA COLON ARROW ]
## ty_arg -> LEFTPAR ty . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ARROW ]
##
## The known suffix of the stack is as follows:
## LEFTPAR ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR UNDERSCORE COLON FLOAT WRITES
##
## Ends in an error in state: 412.
##
## param -> LEFTPAR binder_vars cast . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## LEFTPAR binder_vars cast
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR UNDERSCORE UNDERSCORE WRITES
##
## Ends in an error in state: 399.
##
## list(binder_var) -> binder_var . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## binder_var
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR UNDERSCORE WRITES
##
## Ends in an error in state: 406.
##
## binder_vars_rest -> anon_binder . list(binder_var) [ RIGHTPAR COLON ]
##
## The known suffix of the stack is as follows:
## anon_binder
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE LEFTPAR WRITES
##
## Ends in an error in state: 389.
##
## param -> LEFTPAR . GHOST ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> LEFTPAR . binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> LEFTPAR . GHOST binder_vars_rest RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> LEFTPAR . binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> LEFTPAR . GHOST binder_vars cast RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## ty_arg -> LEFTPAR . comma_list2(ty) RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## ty_arg -> LEFTPAR . RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## ty_arg -> LEFTPAR . ty RIGHTPAR [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE STRING RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## LEFTPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE RANGE STRING WHILE
##
## Ends in an error in state: 415.
##
## param -> ty_arg label . list(label) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## ty_arg label
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE RANGE WHILE
##
## Ends in an error in state: 414.
##
## param -> ty_arg . [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
## param -> ty_arg . label list(label) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 81.
##
## lqualid -> uqualid DOT . lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## uqualid -> uqualid DOT . UIDENT [ DOT ]
## uqualid -> uqualid DOT . UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE UIDENT_QUOTE WRITES
##
## Ends in an error in state: 80.
##
## lqualid -> uqualid . DOT lident [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE TO THEN STRING SO SEMICOLON RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OPAQUE_QUOTE_LIDENT OP4 OP3 OP2 OP1 NAMESPACE MODEL META LTGT LT LRARROW LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LARROW INVARIANT INDUCTIVE IN GT GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AS ARROW AND AMPAMP ]
## uqualid -> uqualid . DOT UIDENT [ DOT ]
## uqualid -> uqualid . DOT UIDENT_QUOTE [ DOT ]
##
## The known suffix of the stack is as follows:
## uqualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE UNDERSCORE WHILE
##
## Ends in an error in state: 418.
##
## list(param) -> param . list(param) [ WRITES WITH VARIANT VAL USE TYPE RETURNS REQUIRES READS RAISES PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## param
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE UNDERSCORE WRITES
##
## Ends in an error in state: 452.
##
## predicate_decl -> labels(lident_rich) params . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich) params
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 418, spurious reduction of production list(param) ->
## In state 419, spurious reduction of production list(param) -> param list(param)
## In state 421, spurious reduction of production params -> list(param)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE WHILE
##
## Ends in an error in state: 438.
##
## labels(lident_rich) -> lident_rich . list(label) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## lident_rich
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE WITH RANGE COLON FLOAT AS
##
## Ends in an error in state: 444.
##
## with_logic_decl -> WITH labels(lident_rich) params option(cast) . option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH labels(lident_rich) params option(cast)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
## In state 263, spurious reduction of production option(cast) -> cast
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE WITH RANGE UNDERSCORE WRITES
##
## Ends in an error in state: 443.
##
## with_logic_decl -> WITH labels(lident_rich) params . option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH labels(lident_rich) params
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 418, spurious reduction of production list(param) ->
## In state 419, spurious reduction of production list(param) -> param list(param)
## In state 421, spurious reduction of production params -> list(param)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE WITH RANGE WRITES
##
## Ends in an error in state: 442.
##
## with_logic_decl -> WITH labels(lident_rich) . params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE WITH WRITES
##
## Ends in an error in state: 437.
##
## with_logic_decl -> WITH . labels(lident_rich) params option(cast) option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE RANGE WRITES
##
## Ends in an error in state: 451.
##
## predicate_decl -> labels(lident_rich) . params option(preceded(EQUAL,term)) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_rich)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 438, spurious reduction of production list(label) ->
## In state 439, spurious reduction of production labels(lident_rich) -> lident_rich list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE PREDICATE WRITES
##
## Ends in an error in state: 435.
##
## decl -> PREDICATE . predicate_decl list(with_logic_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## PREDICATE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE STRING WHILE
##
## Ends in an error in state: 8.
##
## list(label) -> label . list(label) [ WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE SEMICOLON RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL ENSURES END DOT DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM AS ARROW ]
##
## The known suffix of the stack is as follows:
## label
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT FLOAT INTEGER INTEGER WRITES
##
## Ends in an error in state: 66.
##
## typedefn -> EQUAL LT FLOAT INTEGER INTEGER . GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT FLOAT INTEGER INTEGER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT FLOAT INTEGER WRITES
##
## Ends in an error in state: 65.
##
## typedefn -> EQUAL LT FLOAT INTEGER . INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT FLOAT INTEGER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT FLOAT WRITES
##
## Ends in an error in state: 64.
##
## typedefn -> EQUAL LT FLOAT . INTEGER INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT FLOAT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT RANGE INTEGER INTEGER GT WRITES
##
## Ends in an error in state: 43.
##
## separated_nonempty_list(WITH,type_decl) -> type_decl . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(WITH,type_decl) -> type_decl . WITH separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## type_decl
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT RANGE INTEGER INTEGER WRITES
##
## Ends in an error in state: 62.
##
## typedefn -> EQUAL LT RANGE INTEGER INTEGER . GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT RANGE INTEGER INTEGER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT RANGE INTEGER WRITES
##
## Ends in an error in state: 61.
##
## typedefn -> EQUAL LT RANGE INTEGER . INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT RANGE INTEGER
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT RANGE WRITES
##
## Ends in an error in state: 60.
##
## typedefn -> EQUAL LT RANGE . INTEGER INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT RANGE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL LT WRITES
##
## Ends in an error in state: 59.
##
## typedefn -> EQUAL LT . RANGE INTEGER INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## typedefn -> EQUAL LT . FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL LT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE EQUAL WRITES
##
## Ends in an error in state: 58.
##
## model -> EQUAL . [ UIDENT_QUOTE UIDENT RANGE QUOTE_LIDENT PRIVATE OPAQUE_QUOTE_LIDENT MODEL LIDENT_QUOTE LIDENT LEFTPAR LEFTBRC FLOAT BAR ABSTRACT ]
## typedefn -> EQUAL . LT RANGE INTEGER INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## typedefn -> EQUAL . LT FLOAT INTEGER INTEGER GT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EQUAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE INVARIANT LEFTBRC EPSILON RIGHTBRC WRITES
##
## Ends in an error in state: 433.
##
## nonempty_list(invariant) -> invariant . [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## nonempty_list(invariant) -> invariant . nonempty_list(invariant) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## invariant
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE INVARIANT LEFTBRC UIDENT_QUOTE WITH
##
## Ends in an error in state: 379.
##
## invariant -> INVARIANT LEFTBRC term . RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT_QUOTE UIDENT TYPE TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INVARIANT INTEGER INDUCTIVE IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION END CONSTANT COINDUCTIVE CLONE CHECK BEGIN AXIOM ASSUME ASSERT ANY ABSURD ABSTRACT ]
## term_ -> term . ARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LRARROW term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BARBAR term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AND term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . AMPAMP term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . BY term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . SO term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP1 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP2 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP3 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . OP4 term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . EQUAL term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LTGT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . LT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . GT term [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
## term_ -> term . cast [ SO RIGHTBRC OR OP4 OP3 OP2 OP1 LTGT LT LRARROW GT EQUAL COLON BY BARBAR ARROW AND AMPAMP ]
##
## The known suffix of the stack is as follows:
## INVARIANT LEFTBRC term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 123, spurious reduction of production qualid -> UIDENT_QUOTE
## In state 273, spurious reduction of production term_arg_ -> qualid
## In state 241, spurious reduction of production term_ -> term_arg_
## In state 245, spurious reduction of production mk_term(term_) -> term_
## In state 280, spurious reduction of production term -> mk_term(term_)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE INVARIANT LEFTBRC WRITES
##
## Ends in an error in state: 122.
##
## invariant -> INVARIANT LEFTBRC . term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT_QUOTE UIDENT TYPE TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INVARIANT INTEGER INDUCTIVE IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION END CONSTANT COINDUCTIVE CLONE CHECK BEGIN AXIOM ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## INVARIANT LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE INVARIANT WRITES
##
## Ends in an error in state: 121.
##
## invariant -> INVARIANT . LEFTBRC term RIGHTBRC [ WITH WHILE VARIANT VAL USE UIDENT_QUOTE UIDENT TYPE TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INVARIANT INTEGER INDUCTIVE IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION END CONSTANT COINDUCTIVE CLONE CHECK BEGIN AXIOM ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## INVARIANT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL BAR WRITES
##
## Ends in an error in state: 384.
##
## bar_list1(type_case) -> BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC GHOST WRITES
##
## Ends in an error in state: 109.
##
## field_modifiers -> GHOST . [ RANGE MODEL LIDENT_QUOTE LIDENT FLOAT ]
## field_modifiers -> GHOST . MUTABLE [ RANGE MODEL LIDENT_QUOTE LIDENT FLOAT ]
##
## The known suffix of the stack is as follows:
## GHOST
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC MUTABLE GHOST WRITES
##
## Ends in an error in state: 114.
##
## type_field -> field_modifiers . labels(lident_nq) cast [ SEMICOLON RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## field_modifiers
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC MUTABLE WRITES
##
## Ends in an error in state: 107.
##
## field_modifiers -> MUTABLE . [ RANGE MODEL LIDENT_QUOTE LIDENT FLOAT ]
## field_modifiers -> MUTABLE . GHOST [ RANGE MODEL LIDENT_QUOTE LIDENT FLOAT ]
##
## The known suffix of the stack is as follows:
## MUTABLE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC RANGE COLON RANGE RIGHTBRC WRITES
##
## Ends in an error in state: 120.
##
## typedefn -> model abstract LEFTBRC semicolon_list1(type_field) RIGHTBRC . list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## model abstract LEFTBRC semicolon_list1(type_field) RIGHTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC RANGE COLON RANGE SEMICOLON WRITES
##
## Ends in an error in state: 112.
##
## semicolon_list1(type_field) -> type_field SEMICOLON . [ RIGHTBRC ]
## semicolon_list1(type_field) -> type_field SEMICOLON . semicolon_list1(type_field) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## type_field SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC RANGE COLON RANGE WRITES
##
## Ends in an error in state: 111.
##
## semicolon_list1(type_field) -> type_field . [ RIGHTBRC ]
## semicolon_list1(type_field) -> type_field . SEMICOLON [ RIGHTBRC ]
## semicolon_list1(type_field) -> type_field . SEMICOLON semicolon_list1(type_field) [ RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## type_field
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
## In state 117, spurious reduction of production cast -> COLON ty
## In state 118, spurious reduction of production type_field -> field_modifiers labels(lident_nq) cast
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC RANGE WITH
##
## Ends in an error in state: 115.
##
## type_field -> field_modifiers labels(lident_nq) . cast [ SEMICOLON RIGHTBRC ]
##
## The known suffix of the stack is as follows:
## field_modifiers labels(lident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 46, spurious reduction of production list(label) ->
## In state 47, spurious reduction of production labels(lident_nq) -> lident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL LEFTBRC WRITES
##
## Ends in an error in state: 106.
##
## typedefn -> model abstract LEFTBRC . semicolon_list1(type_field) RIGHTBRC list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## model abstract LEFTBRC
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL PRIVATE AXIOM
##
## Ends in an error in state: 72.
##
## typedefn -> model abstract . bar_list1(type_case) list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## typedefn -> model abstract . LEFTBRC semicolon_list1(type_field) RIGHTBRC list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## typedefn -> model abstract . ty list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## model abstract
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL RANGE WRITES
##
## Ends in an error in state: 423.
##
## ty -> ty . ARROW ty [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ARROW ]
## typedefn -> model abstract ty . list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## model abstract ty
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 94, spurious reduction of production ty_arg -> lqualid
## In state 85, spurious reduction of production ty -> ty_arg
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL UIDENT WRITES
##
## Ends in an error in state: 74.
##
## uident_nq -> UIDENT . [ WITH VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE STRING RANGE QUOTE_LIDENT PREDICATE POSITION OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## uqualid -> UIDENT . [ DOT ]
##
## The known suffix of the stack is as follows:
## UIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL UIDENT_QUOTE BAR WRITES
##
## Ends in an error in state: 386.
##
## separated_nonempty_list(BAR,type_case) -> type_case BAR . separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## type_case BAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL UIDENT_QUOTE FLOAT WRITES
##
## Ends in an error in state: 385.
##
## separated_nonempty_list(BAR,type_case) -> type_case . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## separated_nonempty_list(BAR,type_case) -> type_case . BAR separated_nonempty_list(BAR,type_case) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## type_case
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 414, spurious reduction of production param -> ty_arg
## In state 418, spurious reduction of production list(param) ->
## In state 419, spurious reduction of production list(param) -> param list(param)
## In state 421, spurious reduction of production params -> list(param)
## In state 417, spurious reduction of production type_case -> labels(uident_nq) params
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL UIDENT_QUOTE INVARIANT LEFTBRC EPSILON RIGHTBRC WRITES
##
## Ends in an error in state: 382.
##
## list(invariant) -> invariant . list(invariant) [ WITH WHILE VAL USE UIDENT_QUOTE UIDENT TYPE TRY TRUE STRING REAL RANGE RAISE QUOTE_UIDENT PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT NAMESPACE MODEL META MATCH LT LOOP LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR_STAR_RIGHTPAR LEFTPAR LEFTBRC INTEGER INDUCTIVE IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION END CONSTANT COINDUCTIVE CLONE CHECK BEGIN AXIOM ASSUME ASSERT ANY ABSURD ABSTRACT ]
##
## The known suffix of the stack is as follows:
## invariant
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL UIDENT_QUOTE STRING WRITES
##
## Ends in an error in state: 388.
##
## type_case -> labels(uident_nq) . params [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(uident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 7, spurious reduction of production labels(uident_nq) -> uident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL UIDENT_QUOTE WRITES
##
## Ends in an error in state: 73.
##
## uident_nq -> UIDENT_QUOTE . [ WITH VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE STRING RANGE QUOTE_LIDENT PREDICATE POSITION OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
## uqualid -> UIDENT_QUOTE . [ DOT ]
##
## The known suffix of the stack is as follows:
## UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE MODEL WRITES
##
## Ends in an error in state: 69.
##
## typedefn -> model . abstract bar_list1(type_case) list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## typedefn -> model . abstract LEFTBRC semicolon_list1(type_field) RIGHTBRC list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## typedefn -> model . abstract ty list(invariant) [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## model
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE QUOTE_LIDENT STRING WRITES
##
## Ends in an error in state: 51.
##
## list(ty_var) -> ty_var . list(ty_var) [ WITH VAL USE TYPE PREDICATE NAMESPACE MODEL META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## ty_var
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 8, spurious reduction of production list(label) ->
## In state 9, spurious reduction of production list(label) -> label list(label)
## In state 53, spurious reduction of production labels(quote_lident) -> quote_lident list(label)
## In state 55, spurious reduction of production ty_var -> labels(quote_lident)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE QUOTE_LIDENT WRITES
##
## Ends in an error in state: 52.
##
## labels(quote_lident) -> quote_lident . list(label) [ WITH VAL USE TYPE QUOTE_LIDENT PREDICATE NAMESPACE MODEL META LET LEMMA INVARIANT INDUCTIVE GOAL FUNCTION EXCEPTION EQUAL END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## quote_lident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE UNDERSCORE
##
## Ends in an error in state: 430.
##
## late_invariant -> labels(lident_nq) . list(ty_var) nonempty_list(invariant) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## type_decl -> labels(lident_nq) . list(ty_var) typedefn [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 46, spurious reduction of production list(label) ->
## In state 47, spurious reduction of production labels(lident_nq) -> lident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE WITH RANGE QUOTE_LIDENT INVARIANT
##
## Ends in an error in state: 56.
##
## type_decl -> labels(lident_nq) list(ty_var) . typedefn [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_nq) list(ty_var)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 52, spurious reduction of production list(label) ->
## In state 53, spurious reduction of production labels(quote_lident) -> quote_lident list(label)
## In state 55, spurious reduction of production ty_var -> labels(quote_lident)
## In state 51, spurious reduction of production list(ty_var) ->
## In state 54, spurious reduction of production list(ty_var) -> ty_var list(ty_var)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE WITH RANGE UNDERSCORE
##
## Ends in an error in state: 49.
##
## type_decl -> labels(lident_nq) . list(ty_var) typedefn [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## labels(lident_nq)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 46, spurious reduction of production list(label) ->
## In state 47, spurious reduction of production labels(lident_nq) -> lident_nq list(label)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE WITH WRITES
##
## Ends in an error in state: 44.
##
## separated_nonempty_list(WITH,type_decl) -> type_decl WITH . separated_nonempty_list(WITH,type_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## type_decl WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE RANGE WRITES
##
## Ends in an error in state: 46.
##
## labels(lident_nq) -> lident_nq . list(label) [ WITH VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE SEMICOLON RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION EQUAL END DOT CONSTANT COMMA COLON COINDUCTIVE CLONE BAR AXIOM AS ARROW ]
##
## The known suffix of the stack is as follows:
## lident_nq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE TYPE WRITES
##
## Ends in an error in state: 39.
##
## decl -> TYPE . with_list1(type_decl) [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## decl -> TYPE . late_invariant [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE EXPORT WRITES
##
## Ends in an error in state: 14.
##
## use -> EXPORT . tqualid [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## EXPORT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE IMPORT FALSE
##
## Ends in an error in state: 34.
##
## use -> boption(IMPORT) . tqualid [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use -> boption(IMPORT) . tqualid AS UIDENT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use -> boption(IMPORT) . tqualid AS UIDENT_QUOTE [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## boption(IMPORT)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE STRING WRITES
##
## Ends in an error in state: 28.
##
## any_qualid -> any_qualid . DOT sident [ DOT ]
## tqualid -> any_qualid . DOT UIDENT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
## tqualid -> any_qualid . DOT UIDENT_QUOTE [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT WITH
##
## Ends in an error in state: 572.
##
## list(theory_decl) -> theory_decl . list(theory_decl) [ END ]
##
## The known suffix of the stack is as follows:
## theory_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 16, spurious reduction of production tqualid -> UIDENT
## In state 35, spurious reduction of production use -> boption(IMPORT) tqualid
## In state 33, spurious reduction of production use_clone -> USE use
## In state 571, spurious reduction of production theory_decl -> use_clone
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT WRITES
##
## Ends in an error in state: 16.
##
## ident -> UIDENT . [ DOT ]
## tqualid -> UIDENT . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## UIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT_QUOTE AS WRITES
##
## Ends in an error in state: 36.
##
## use -> boption(IMPORT) tqualid AS . UIDENT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
## use -> boption(IMPORT) tqualid AS . UIDENT_QUOTE [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## boption(IMPORT) tqualid AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT_QUOTE DOT UIDENT WRITES
##
## Ends in an error in state: 31.
##
## ident -> UIDENT . [ DOT ]
## tqualid -> any_qualid DOT UIDENT . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid DOT UIDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT_QUOTE DOT UIDENT_QUOTE WRITES
##
## Ends in an error in state: 30.
##
## ident -> UIDENT_QUOTE . [ DOT ]
## tqualid -> any_qualid DOT UIDENT_QUOTE . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid DOT UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT_QUOTE DOT WRITES
##
## Ends in an error in state: 29.
##
## any_qualid -> any_qualid DOT . sident [ DOT ]
## tqualid -> any_qualid DOT . UIDENT [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
## tqualid -> any_qualid DOT . UIDENT_QUOTE [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## any_qualid DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE UIDENT_QUOTE WRITES
##
## Ends in an error in state: 15.
##
## ident -> UIDENT_QUOTE . [ DOT ]
## tqualid -> UIDENT_QUOTE . [ WITH VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM AS ]
##
## The known suffix of the stack is as follows:
## UIDENT_QUOTE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE USE WRITES
##
## Ends in an error in state: 12.
##
## use_clone -> USE . use [ VAL USE TYPE PREDICATE NAMESPACE META LET LEMMA INDUCTIVE GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## USE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE WITH
##
## Ends in an error in state: 11.
##
## theory -> theory_head . list(theory_decl) END [ THEORY MODULE EOF ]
##
## The known suffix of the stack is as follows:
## theory_head
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production list(label) ->
## In state 7, spurious reduction of production labels(uident_nq) -> uident_nq list(label)
## In state 10, spurious reduction of production theory_head -> THEORY labels(uident_nq)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY UIDENT_QUOTE WRITES
##
## Ends in an error in state: 4.
##
## labels(uident_nq) -> uident_nq . list(label) [ WITH VAL USE UNDERSCORE UIDENT_QUOTE UIDENT TYPE RANGE QUOTE_LIDENT PREDICATE OPAQUE_QUOTE_LIDENT NAMESPACE MODEL META LIDENT_QUOTE LIDENT LET LEMMA LEFTPAR INVARIANT INDUCTIVE GOAL FUNCTION FLOAT EXCEPTION END CONSTANT COINDUCTIVE CLONE BAR AXIOM ]
##
## The known suffix of the stack is as follows:
## uident_nq
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: THEORY WRITES
##
## Ends in an error in state: 1.
##
## theory_head -> THEORY . labels(uident_nq) [ USE TYPE PREDICATE NAMESPACE META LEMMA INDUCTIVE GOAL FUNCTION END CONSTANT COINDUCTIVE CLONE AXIOM ]
##
## The known suffix of the stack is as follows:
## THEORY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

logic_file: WRITES
##
## Ends in an error in state: 0.
##
## logic_file' -> . logic_file [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>
