

(** {1 Theory of maps} *)

(** {2 Generic Maps} *)

module Map

  type map 'a 'b = 'a -> 'b

  let function get (f: map 'a 'b) (x: 'a) : 'b = f x

  let ghost function set (f: map 'a 'b) (x: 'a) (v: 'b) : map 'a 'b =
    fun y -> if pure {y = x} then v else f y

end

module MapBrackets

  use export Map

  (** syntactic sugar *)
  let function ([]) (f: map 'a 'b) (x: 'a) : 'b = f x

  let ghost function ([<-]) (f: map 'a 'b) (x: 'a) (v: 'b) : map 'a 'b =
    set f x v

end

module Const

  use Map

  let function const (v: 'b) : map 'a 'b = fun _ -> v

end

module MapExt

  predicate (==) (m1 m2: 'a -> 'b) = forall x: 'a. m1 x = m2 x

  lemma extensionality:
    forall m1 m2: 'a -> 'b. m1 == m2 -> m1 = m2
  (* This lemma is actually provable in Why3, because of how
     eliminate_epsilon handles equality to a lambda-term. *)

end

(** {2 Sorted Maps (indexed by integers)} *)

module MapSorted

  use int.Int
  use Map

  type elt

  predicate rel elt elt
  (** the order relation to compare elements; can be strict or large *)

  predicate sorted_sub (a: map int elt) (l u: int) =
    forall i1 i2 : int. l <= i1 < i2 < u -> rel (a i1) (a i2)
  (** `sorted_sub a l u` is true whenever the array segment `a(l..u-1)`
      is sorted w.r.t order relation `rel` *)

end

(** {2 Maps Equality (indexed by integers)} *)

module MapEq

  use int.Int
  use Map

  predicate map_eq_sub (a1 a2 : map int 'a) (l u : int) =
    forall i:int. l <= i < u -> a1 i = a2 i

end

module MapExchange

  use int.Int
  use Map

  predicate exchange (a1 a2: map int 'a) (l u i j: int) =
    l <= i < u /\ l <= j < u /\
    a1 i = a2 j /\ a1 j = a2 i /\
    (forall k:int. l <= k < u -> k <> i -> k <> j -> a1 k = a2 k)

  lemma exchange_set :
    forall a: map int 'a, l u i j: int.
    l <= i < u -> l <= j < u ->
    exchange a (set (set a i (a j)) j (a i)) l u i j

end

module NumOfIndex

  use int.Int
  use int.NumOf as N
  use Map

  function is_true_i (p: int -> 'a -> bool) (m: map int 'a) : int -> bool =
    fun i -> p i (m i)

  function numof_i (p: int -> 'a -> bool) (m: map int 'a) (l u: int) : int
    = N.numof (is_true_i p m) l u

end

module NumOf

  use int.Int
  use int.NumOf as N
  use Map

  function is_true (p: 'a -> bool) (m: map int 'a) : int -> bool =
    fun i -> p (m i)

  function numof (p: 'a -> bool) (m: map int 'a) (l u: int) : int
    = N.numof (is_true p m) l u

  lemma numof_exchange :
    forall m: map int 'a, l u i j: int, x y: 'a, p.
    l <= i < u -> l <= j < u -> i <> j ->
    numof p (set (set m i x) j y) l u =
    numof p (set (set m i y) j x) l u

end

(** {2 Number of occurrences} *)

module Occ

  use int.Int
  use int.NumOf
  use Map

  function is_eq (x: 'a) (m: map int 'a) : int->bool = fun i -> m i = x

  (** number of occurrences of `v` in `m`
      between `l` included and `u` excluded *)
  function occ (v: 'a) (m: map int 'a) (l u: int) : int =
    numof (is_eq v m) l u

  lemma occ_pos:
    forall m: map int 'a, l u i: int.
    l <= i < u -> occ (m i) m l u > 0

  lemma occ_exchange :
    forall m: map int 'a, l u i j: int, x y z: 'a.
    l <= i < u -> l <= j < u -> i <> j ->
    occ z (set (set m i x) j y) l u =
    occ z (set (set m i y) j x) l u

end

module MapPermut

  use int.Int
  use Map
  use Occ

  predicate permut (m1 m2: map int 'a) (l u: int) =
    forall v: 'a. occ v m1 l u = occ v m2 l u

  lemma permut_trans: (* provable, yet useful *)
    forall a1 a2 a3 : map int 'a. forall l u : int.
    permut a1 a2 l u -> permut a2 a3 l u -> permut a1 a3 l u

  lemma permut_exists :
    forall a1 a2: map int 'a, l u i: int.
    permut a1 a2 l u -> l <= i < u ->
    exists j: int. l <= j < u /\ a1 j = a2 i

end


(** {2 Injectivity and surjectivity for maps (indexed by integers)} *)

module MapInjection

  use int.Int
  use export Map

  predicate injective (a: map int int) (n: int) =
    forall i j: int. 0 <= i < n -> 0 <= j < n -> i <> j -> a i <> a j
  (** `injective a n` is true when `a` is an injection
      on the domain `(0..n-1)` *)

  predicate surjective (a: map int int) (n: int) =
    forall i: int. 0 <= i < n -> exists j: int. (0 <= j < n /\ a j = i)
  (** `surjective a n` is true when `a` is a surjection
      from `(0..n-1)` to `(0..n-1)` *)

  predicate range (a: map int int) (n: int) =
    forall i: int. 0 <= i < n -> 0 <= a i < n
  (** `range a n` is true when `a` maps the domain
      `(0..n-1)` into `(0..n-1)` *)

  lemma injective_surjective:
    forall a: map int int, n: int.
    injective a n -> range a n -> surjective a n
  (** main lemma: an injection on `(0..n-1)` that
      ranges into `(0..n-1)` is also a surjection *)

  use Occ

  lemma injection_occ:
    forall m: map int int, n: int.
    injective m n <-> forall v:int. (occ v m 0 n <= 1)

end

(***

(** {2 Parametric Maps} *)

module MapParam

  type idx
  type elt
  type map

  (** if `'b` is an infinite type, then `map 'a 'b` is infinite *)
  meta "material_type_arg" type map, 1

  function get (map 'a 'b) 'a : 'b
  function set (map 'a 'b) 'a 'b : map 'a 'b

  (** syntactic sugar *)
  function ([])   (a : map 'a 'b) (i : 'a) : 'b = get a i
  function ([<-]) (a : map 'a 'b) (i : 'a) (v : 'b) : map 'a 'b = set a i v

  axiom Select_eq :
    forall m : map 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [m[a1 <- b][a2]].
    a1 = a2 -> m[a1 <- b][a2]  = b

  axiom Select_neq :
    forall m : map 'a 'b. forall a1 a2 : 'a.
    forall b : 'b [m[a1 <- b][a2]].
    a1 <> a2 -> m[a1 <- b][a2] = m[a2]

  function const 'b : map 'a 'b

  axiom Const : forall b:'b, a:'a. (const b)[a] = b

end
*)
