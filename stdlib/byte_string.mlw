
module Char
  use int.Int
  use mach.int.Byte

  type char = { char_content : byte }

  let function code (c: char): int = to_int c.char_content

  function chr (n: int): char

  axiom code_chr: forall n. 0 <= n < 256 -> code (chr n) = n

  let chr (n: int): char
    requires { 0 <= n < 256 }
    ensures  { result = chr n }
  = { char_content = of_int n }

  lemma chr_code: forall c. chr (code c) = c

  let (=) (c1 c2: char): bool
    ensures { result <-> c1.char_content = c2.char_content }
  = c1.char_content = c2.char_content
end

module String
  use int.Int
  use int.MinMax
  use Char
  use seq.Seq as Seq
  use seq.FreeMonoid

  type cstring = { str_content : Seq.seq char }
  meta coercion function str_content

  let function length (s: cstring) : int = Seq.length s.str_content

  lemma length_nonnegative: forall s. 0 <= length s

  function get (s: cstring) (i: int): char = Seq.get s i
  function ([]) (s: cstring) (i: int): char = get s i

  let get (s: cstring) (i: int): char
    requires { 0 <= i < length s }
    ensures  { result = s[i] }
  = Seq.get s.str_content i

  let ([]) (s: cstring) (i: int) : char
    requires { 0 <= i < length s }
    ensures  { result = s[i] }
  = get s i

  let function empty: cstring = { str_content = Seq.empty }

  let function singleton (c: char): cstring
    ensures { length result = 1 }
    ensures { result[0] = c }
  = { str_content = Seq.singleton c }

  let predicate (==) (s1 s2: cstring)
    ensures { result <-> length s1 = length s2 &&
              forall i: int. 0 <= i < length s1 -> s1[i] = s2[i] }
    ensures { result -> s1 = s2 }
  = Seq.(s1.str_content == s2.str_content)

  let function cons (c: char) (s: cstring): cstring
    ensures { length result = length s + 1}
    ensures { result[0] = c }
    ensures { forall i. 1 <= i < length result -> result[i] = s[i - 1]}
  = { str_content = Seq.cons c s.str_content }

  let function make (len: int) (c: char): cstring
    requires { 0 <= len }
    ensures  { length result = len }
    ensures  { forall i. 0 <= i < len -> result[i] = c }
  = { str_content = Seq.create len (fun _ -> c) }

  let function init (len: int) (f: int -> char): cstring
    requires { 0 <= len }
    ensures  { length result = len }
    ensures  { forall i. 0 <= i < len -> result[i] = f i }
  = { str_content = Seq.create len f }

  let function sub (s: cstring) (i: int) (j: int): cstring
    requires { 0 <= i <= j <= length s }
    ensures  { length result = j - i }
    ensures  { forall k. 0 <= k < j - i -> result[k] = s[i + k] }
  = { str_content = Seq.(s.str_content[i..j]) }

  let function concat (s1 s2: cstring): cstring
  = { str_content = Seq.(s1.str_content ++ s2.str_content) }

  let rec function map (f: char -> char) (s: cstring): cstring
    ensures { length result = length s }
    ensures { forall i. 0 <= i < length result -> result[i] = f s[i] }
  = variant { length s }
    if s == empty then empty else
      cons (f s[0]) (map f (sub s 1 (length s)))

  exception Not_found

  let rec index_from (s: cstring) (j: int) (c: char): int
    requires { 0 <= j <= length s }
    ensures { s[result] = c }
    raises  { Not_found -> forall i. j <= i < length s -> s[i] <> c }
  = variant { length s - j }
    if j = length s then raise Not_found else
      if Byte.(s[j] = c) then j else
        index_from s (j+1) c

  let index (s: cstring) (c: char): int
    ensures { s[result] = c }
    raises  { Not_found -> forall i. 0 <= i < length s -> s[i] <> c }
  = index_from s 0 c

  use seq.Mem

  let rec predicate contains (s: cstring) (c: char)
    ensures { result <-> mem c s }
  = variant { length s }
    if s == empty then false else
      if Byte.(s[0] = c) then true else
        contains (sub s 1 (length s)) c

  (* Do we need Sys.max_string_length? *)

end

module OCaml

  use int.Int
  use mach.int.Int63
  use String
  use Char

  (* In OCaml max_string_length is 144_115_188_075_855_863 *)

  val get (s: cstring) (i: int63) : char
    requires { 0 <= i < length s }
    ensures  { result = get s i }

  let ([]) (s: cstring) (i: int63) : char
    requires { 0 <= i < length s }
    ensures  { result = get s i }
  = get s i

  val code (c: char) : int63
    ensures { result = code c }

  val chr (n: int63) : char
    requires { 0 <= n < 256 }
    ensures  { result = chr n }

  val partial length (s: cstring) : int63
    ensures { result = length s }

  val sub (s: cstring) (start: int63) (len: int63) : cstring
    requires { 0 <= start <= length s }
    requires { 0 <= len <= length s - start }
    ensures  { result = sub s start len }

  val make (size: int63) (v: char) : cstring
    requires { 0 <= size }
    ensures  { result = make size v }

end

module StringBuffer

  use int.Int
  use mach.int.Int63
  use String
  use Char
  use seq.Seq as Seq

  type buffer = abstract {
    mutable str: cstring;
  }
  meta coercion function str

  val create (_: int63) : buffer
    ensures { result.str = empty }

  val length (b: buffer) : int63
    ensures { result = length b.str }

  val contents (b: buffer) : cstring
    ensures { result = b.str }

  val clear (b: buffer) : unit
    writes  { b }
    ensures { b.str = empty }

  val reset (b: buffer) : unit
    writes  { b }
    ensures { b.str = empty }

  val sub (b: buffer) (ofs len: int63) : cstring
    requires { 0 <= ofs /\ 0 <= len /\ ofs + len <= length b.str }
    ensures  { result = sub b.str ofs len }

  val add_char (b: buffer) (c: char) : unit
    writes   { b }
    ensures  { b.str = concat (old b.str) (singleton c) }

  val add_string (b: buffer) (s: cstring) : unit
    writes   { b }
    ensures  { b.str = concat (old b.str) s }

  val truncate (b: buffer) (n: int63) : unit
    requires { 0 <= n <= length b.str }
    writes   { b }
    ensures  { b.str = sub (old b.str) 0 n }

end