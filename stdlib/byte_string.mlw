module CString

  use int.Int
  use int.MinMax
  use mach.int.Byte
  use export seq.Seq
  use seq.FreeMonoid

  type char = byte
  type cstring = seq char

  goal length_ge_0: forall s: cstring. length s >= 0

  goal concat_assoc: forall s1 s2 s3: cstring.
    (s1 ++ s2) ++ s3 = s1 ++ (s2 ++ s3)

  goal concat_empty: forall s: cstring.
    s ++ empty = empty ++ s = s

  goal length_empty: length (empty:cstring) = 0

  goal length_concat: forall s1 s2: cstring.
    length (s1 ++ s2) = length s1 + length s2

  exception Break

  val function first_diff (s1 s2: cstring) : int
    ensures { 0 <= result <= length s1 && result <= length s2 }
    ensures { forall i. 0 <= i < result -> s1[i] = s2[i] }
    ensures { (result = length s1 /\ length s2 >= length s1) ||
              (result = length s2 /\ length s1 >= length s2) ||
              s1[result] <> s2[result] }
  (* = let ref i = 0 in *)
  (*   try *)
  (*     while i < length s1 && i < length s2 do *)
  (*       variant   { min (length s1) (length s2) - i } *)
  (*       invariant { forall j. 0 <= j < i -> s1[j] = s2[j] } *)
  (*       invariant { 0 <= i <= min (length s1) (length s2) } *)
  (*       if s1[i] <> s2[i] then raise Break *)
  (*       else i <- i + 1 *)
  (*     done; *)
  (*     i *)
  (*   with Break -> i end *)

  goal first_diff_empty: forall s: cstring.
    first_diff s empty = 0

  val predicate lt (s1 s2: cstring)
    ensures { let x = first_diff s1 s2 in
              result <->
                (x >= length s1 && x < length s2) ||
                (x < length s1 && x < length s2 && s1[x] < s2[x]) }
  (* = let x = first_diff s1 s2 in *)
  (*   if x >= length s1 && x < length s2 then True else *)
  (*     if x < length s2 then s1[x] < s2[x] else False *)

  goal lt_empty: forall s.
    s <> empty -> lt empty s

  goal lt_not_com: forall s1 s2.
    lt s1 s2 -> not (lt s2 s1)

  goal lt_ref: forall s1. not (lt s1 s1)

  goal lt_trans: forall s1 s2 s3.
    lt s1 s2 && lt s2 s3 -> lt s1 s3

  val predicate le (s1 s2: cstring)
    ensures { result <-> lt s1 s2 || s1 = s2 }

  goal le_empty: forall s: cstring.
    le empty s

  goal le_ref: forall s1: cstring.
    le s1 s1

  goal lt_le: forall s1 s2: cstring.
    lt s1 s2 -> le s1 s2

  goal lt_le_eq: forall s1 s2: cstring.
    le s1 s2 -> lt s1 s2 || s1 = s2

  goal le_trans: forall s1 s2 s3: cstring.
    le s1 s2 && le s2 s3 -> le s1 s3

  val function s_at (s: cstring) (i: int) : cstring
    ensures { 0 <= i < length s -> result = singleton s[i] }
    ensures { i < 0 || i >= length s -> result = empty }
  (* = if 0 <= i < length s then singleton s[i] else empty *)

  goal at_out_of_range: forall s, i.
    i < 0 || i >= length s -> s_at s i = empty

  goal at_empty: forall i.
    s_at empty i = empty

  goal at_length: forall s i.
    let j = s_at s i in
    if 0 <= i < length s then length j = 1 else length j = 0

  goal concat_at: forall s1 s2: cstring.
    let s = s1 ++ s2 in
    forall i. (0 <= i < length s1 -> s_at s i = s_at s1 i) &&
              (length s1 <= i < length s -> s_at s i = s_at s2 (i - length s1))

  let function substring (s: cstring) (ofs len: int) : cstring =
    if 0 <= ofs <= length s && len >= 0 then
      s[ofs .. min (ofs + len) (length s)]
    else empty

  goal substring_out_of_range: forall s i x.
    i < 0 || i >= length s -> substring s i x = empty

  goal substring_of_length_zero_or_less: forall s i x.
    x <= 0 -> substring s i x = empty

  goal substring_of_empty: forall i x.
    substring empty i x = empty

  goal substring_smaller: forall s i x.
    length (substring s i x) <= length s

  goal substring_smaller_x: forall s i x.
    x >= 0 -> length (substring s i x) <= x

  goal substring_length: forall s i x.
    x >= 0 && 0 <= i < length s ->
      if i + x > length s then
        length (substring s i x) = length s - i
      else length (substring s i x) = x

  goal substring_at: forall s i.
    s_at s i = substring s i 1

  goal substring_substring:
    forall s ofs len ofs' len'.
    0 <= ofs <= length s -> 0 <= len -> ofs + len <= length s ->
    0 <= ofs' <= len -> 0 <= len' -> ofs' + len' <= len ->
    substring (substring s ofs len) ofs' len' = substring s (ofs + ofs') len'

  (* TODO: cannot prove *)
  goal concat_substring:
    forall s ofs len len'.
    0 <= ofs <= length s -> 0 <= len -> ofs + len <= length s ->
    0 <= len' -> 0 <= ofs + len + len' <= length s ->
    (substring s ofs len) ++ (substring s (ofs+len) len') ==
    substring s ofs (len + len')

  val predicate prefixof (s1 s2: cstring)
    ensures { result <-> first_diff s1 s2 = length s1 }
  (* = if first_diff s1 s2 = length s1 then True else False *)

  (* TODO: proof needs `assert (s1 == substring s2 0 (length s1))` *)
  goal prefixof_substring: forall s1 s2.
    prefixof s1 s2 <-> s1 = substring s2 0 (length s1)

  goal prefixof_concat: forall s1 s2.
    prefixof s1 (s1 ++ s2)

  goal prefixof_empty: forall s2.
    prefixof empty s2

  goal prefixof_empty2: forall s1.
    s1 <> empty -> not (prefixof s1 empty)

  val function rev (s: cstring) : cstring
    ensures { length result = length s }
    ensures { forall i. 0 <= i < length s -> result[i] = s[length s - i - 1] }

  val predicate suffixof (s1 s2: cstring)
    ensures { result <-> prefixof (rev s1) (rev s2) }
  (* = prefixof (reverse s1) (reverse s2) *)

  goal suffixof_substring: forall s1 s2.
    suffixof s1 s2 <-> s1 = substring s2 (length s2 - length s1) (length s1)

  goal suffixof_concat: forall s1 s2.
    suffixof s2 (s1 ++ s2)

  goal suffixof_empty: forall s2.
    suffixof empty s2

  goal suffixof_empty2: forall s1.
    s1 <> empty -> not (suffixof s1 empty)

  val predicate contains (s1 s2: cstring)
    ensures {
      result <-> exists i.
        0 <= i <= length s1 /\
        substring s1 i (length s2) == s2
    }

  goal contains_prefixof: forall s1 s2.
    prefixof s1 s2 -> contains s2 s1

  goal contains_suffixof: forall s1 s2.
    suffixof s1 s2 -> contains s2 s1

  goal contains_empty: forall s2.
    contains empty s2 <-> s2 = empty

  goal contains_empty2: forall s1.
    contains s1 empty

  goal contains_substring: forall s1 s2 i.
    substring s1 i (length s2) = s2 -> contains s1 s2

  (*** The following should hold, but are not proved by SMT provers *)
  (*** goal substring_contains: forall s1 s2.
    contains s1 s2 -> exists i. substring s1 i (length s2) = s2 *)

  goal contains_concat: forall s1 s2.
    contains (s1 ++ s2) s1 && contains (s1 ++ s2) s2

  goal contains_at: forall s1 s2 i.
    s_at s1 i = s2 -> contains s1 s2

  (*** The following should hold, but are not proved by SMT provers *)
  (*** goal at_contains: forall s1 s2.
    contains s1 s2 && length s2 = 1 -> exists i. s_at s1 i = s2 *)

  predicate is_indexof (s1 s2: cstring) (ofs index: int) =
    0 <= ofs <= index <= length s1 &&
    substring s1 index (length s2) == s2

  val function indexof (s1 s2: cstring) (ofs: int) : int
    ensures { is_indexof s1 s2 ofs result }
    ensures { forall i. ofs <= i < result /\ is_indexof s1 s2 ofs i -> i >= result }

  goal indexof_empty: forall s i.
    0 <= i <= length s -> indexof s empty i = i

  goal indexof_empty1: forall s i.
    let j = indexof empty s i in
    j = -1 || (s = empty && i = j = 0)

  goal indexof_contains: forall s1 s2.
    let j = indexof s1 s2 0 in
    contains s1 s2 ->
      0 <= j <= length s1 && substring s1 j (length s2) = s2

  goal contains_indexof: forall s1 s2 i.
    indexof s1 s2 i >= 0 -> contains s1 s2

  goal not_contains_indexof: forall s1 s2 i.
    not (contains s1 s2)  -> indexof s1 s2 i = -1

  goal substring_indexof: forall s1 s2 i.
    let j = indexof s1 s2 i in
    j >= 0 -> substring s1 j (length s2) = s2

  goal indexof_out_of_range: forall i s1 s2.
    not (0 <= i <= length s1) -> indexof s1 s2 i = -1

  goal indexof_in_range: forall s1 s2 i.
    let j = indexof s1 s2 i in
    0 <= i <= length s1 -> j = -1 || i <= j <= length s1

  goal indexof_contains_substring: forall s1 s2 i.
    0 <= i <= length s1 && contains (substring s1 i (length s1 - i)) s2 ->
      i <= indexof s1 s2 i <= length s1



end