(** {1 Arrays} *)

(** {2 Generic Arrays}

The length is a non-mutable field, so that we get for free that
modification of an array does not modify its length.

*)

module Array

  use int.Int
  use export seq.Seq

  type array [@extraction:array] 'a = private {
    mutable ghost elts: seq 'a;
                length: int
  } invariant { 0 <= length = #elts }
  meta coercion function elts

  val ([]) (a: array 'a) (i: int) : 'a
    requires { [@expl:index in array bounds] 0 <= i < #a }
    ensures  { result = a[i] }

  val ([]<-) (a: array 'a) (i: int) (v: 'a) : unit
    writes   { a }
    requires { [@expl:index in array bounds] 0 <= i < #a }
    ensures  { a = (old a)[i <- v] }

  (** unsafe get/set operations with no precondition *)

  exception OutOfBounds

  let defensive_get (a: array 'a) (i: int)
    ensures { 0 <= i < #a /\ result = a[i] }
    raises  { OutOfBounds -> i < 0 \/ i >= #a }
  = if i < 0 || i >= length a then raise OutOfBounds;
    a[i]

  let defensive_set (a: array 'a) (i: int) (v: 'a)
    ensures { 0 <= i < #a }
    ensures { a = (old a)[i <- v] }
    raises  { OutOfBounds -> (i < 0 \/ i >= #a) /\ a = old a }
  = if i < 0 || i >= length a then raise OutOfBounds;
    a[i] <- v

  val function make [@extraction:array_make] (n: int) (v: 'a) : array 'a
    requires { [@expl:array creation size] n >= 0 }
    ensures { forall i. 0 <= i < n -> result[i] = v }
    ensures { #result = n }

  val empty () : array 'a
    ensures { #result = 0 }

  let copy (a: array 'a) : array 'a
    ensures  { result.elts = a.elts }
  =
    let len = length a in
    if len = 0 then empty ()
    else begin
      let b = make len a[0] in
      for i = 1 to len - 1 do
        invariant { forall k. 0 <= k < i -> b[k] = a[k] }
        b[i] <- a[i]
      done;
      b
    end

  let sub (a: array 'a) (ofs: int) (len: int) : array 'a
    requires { 0 <= ofs /\ 0 <= len /\ ofs + len <= #a }
    ensures  { result = a[ofs .. ofs+len] }
  =
    if length a = 0 then begin
     assert { len = 0 };
     empty ()
    end else begin
      let b = make len a[0] in
      for i = 0 to len-1 do
        invariant { forall k. 0 <= k < i -> b[k] = a[ofs+k] }
        b[i] <- a[ofs+i];
      done;
      b
    end

  let fill (a: array 'a) (ofs: int) (len: int) (v: 'a) : unit
    requires { 0 <= ofs /\ 0 <= len /\ ofs + len <= #a }
    ensures  { forall i.
      (0 <= i < ofs \/ ofs + len <= i < #a) -> a[i] = old a[i] }
    ensures  { forall i. ofs <= i < ofs + len -> a[i] = v }
  =
    for k = 0 to len - 1 do
      invariant { forall i:int.
        (0 <= i < ofs \/ ofs + len <= i < #a) -> a[i] = old a[i] }
      invariant { forall i:int. ofs <= i < ofs + k -> a[i] = v }
      a[ofs + k] <- v
    done

  let blit (a1: array 'a) (ofs1: int)
           (a2: array 'a) (ofs2: int) (len: int) : unit
    requires { 0 <= ofs1 /\ 0 <= len /\ ofs1 + len <= #a1 }
    requires { 0 <= ofs2 /\             ofs2 + len <= #a2 }
    ensures  { forall i.
      (0 <= i < ofs2 \/ ofs2 + len <= i < #a2) -> a2[i] = old a2[i] }
    ensures  { forall i.
      ofs2 <= i < ofs2 + len -> a2[i] = a1[ofs1 + i - ofs2] }
  =
    for i = 0 to len - 1 do
      invariant { forall k. not (0 <= k < i) -> a2[ofs2 + k] = old a2[ofs2 + k] }
      invariant { forall k. 0 <= k < i -> a2[ofs2 + k] = a1[ofs1 + k] }
      a2[ofs2 + i] <- a1[ofs1 + i];
    done

  let append (a1: array 'a) (a2: array 'a) : array 'a
    ensures { result = a1 ++ a2 }
  =
    if length a1 = 0 then copy a2
    else begin
      let a = make (length a1 + length a2) a1[0] in
      blit a1 0 a 0 (length a1);
      blit a2 0 a (length a1) (length a2);
      a
    end

  let self_blit (a: array 'a) (ofs1: int) (ofs2: int) (len: int) : unit
    requires { 0 <= ofs1 /\ 0 <= len /\ ofs1 + len <= #a }
    requires { 0 <= ofs2 /\             ofs2 + len <= #a }
    ensures  { forall i.
      (0 <= i < ofs2 \/ ofs2 + len <= i < #a) -> a[i] = old a[i] }
    ensures  { forall i.
      ofs2 <= i < ofs2 + len -> a[i] = old a[ofs1 + i - ofs2] }
  =
    if ofs1 <= ofs2 then (* from right to left *)
      for k = len - 1 downto 0 do
        invariant  { forall i:int.
          (0 <= i <= ofs2 + k \/ ofs2 + len <= i < #a) ->
          a[i] = (old a)[i] }
        invariant  { forall i:int.
          ofs2 + k < i < ofs2 + len -> a[i] = (old a)[ofs1 + i - ofs2] }
        a[ofs2 + k] <- a[ofs1 + k]
      done
    else (* from left to right *)
      for k = 0 to len - 1 do
        invariant  { forall i:int.
          (0 <= i < ofs2 \/ ofs2 + k <= i < #a) ->
          a[i] = (old a)[i] }
        invariant  { forall i:int.
          ofs2 <= i < ofs2 + k -> a[i] = (old a)[ofs1 + i - ofs2] }
        a[ofs2 + k] <- a[ofs1 + k]
      done

  (*** TODO?
     - concat : 'a array list -> 'a array
     - to_list
     - of_list
  *)

end

module Init

  use int.Int
  use export Array

  let init (n: int) (f: int -> 'a) : array 'a
    requires { [@expl:array creation size] n >= 0 }
    ensures  { result = create n f }
  =
    if n = 0 then empty ()
    else begin
      let a = make n (f 0) in
      for i = 1 to n - 1 do
        invariant { forall k. 0 <= k < i -> a[k] = f k }
        a[i] <- f i
      done;
      a
    end


end

module Swap

  use int.Int
  use Array
  use seq.Permut

  let swap (a: array 'a) (i: int) (j: int) (ghost p: permutation) :
      (ghost q: permutation)
    requires { 0 <= i < #a /\ 0 <= j < #a }
    requires { #p = #a }
    ensures  { a = (old a)[i <- old a[j]][j <- old a[i]] }
    ensures  { forall b: seq 'a, l r. 0 <= l <= i < r <= #a -> l <= j < r ->
               permut b (old a) l r p -> permut b a l r q }
  = let v = a[i] in
    a[i] <- a[j];
    a[j] <- v;
    ghost compose p (transpose #(p.forward) i j)

end

module ToList
  use int.Int
  use Array
  use list.List

  let rec function to_list (a: array 'a) (l u: int) : list 'a
    requires { l >= 0 /\ u <= a.length }
    variant  { u - l }
  = if u <= l then Nil else Cons a[l] (to_list a (l+1) u)

  use list.Append

  let rec lemma to_list_append (a: array 'a) (l m u: int)
    requires { 0 <= l <= m <= u <= a.length }
    variant  { m - l }
    ensures  { to_list a l m ++ to_list a m u = to_list a l u }
  = if l < m then to_list_append a (l+1) m u

end


(** {2 Number of inversions in an array of integers}

    We show that swapping two elements that are ill-sorted decreases
    the number of inversions. Useful to prove the termination of
    sorting algorithms that use swaps. *)

module Inversions

  use Array
  use int.Int
  use int.Sum
  use int.NumOf

  (* to prove termination, we count the total number of inversions *)
  predicate inversion (a: array int) (i j: int) =
    a[i] > a[j]

  function inversions_for (a: array int) (i: int) : int =
    numof (inversion a i) i #a

  function inversions (a: array int) : int =
    sum (inversions_for a) 0 #a

  (* the key lemma to prove termination: whenever we swap two consecutive
     values that are ill-sorted, the total number of inversions decreases *)
  let lemma exchange_inversion (a1 a2: array int) (i0: int)
    requires { 0 <= i0 < #a1 - 1 }
    requires { a1[i0] > a1[i0 + 1] }
    requires { a2 = a1[i0 <- a1[i0 + 1]][i0 + 1 <- a1[i0]] }
    ensures  { inversions a2 < inversions a1 }
  = assert { inversion a1 i0 (i0+1) };
    assert { not (inversion a2 i0 (i0+1)) };
    assert { forall i. 0 <= i < i0 ->
             inversions_for a2 i = inversions_for a1 i
             by numof (inversion a2 i) i (#a2)
              = numof (inversion a2 i) i i0
              + numof (inversion a2 i) i0 (i0+1)
              + numof (inversion a2 i) (i0+1) (i0+2)
              + numof (inversion a2 i) (i0+2) (#a2)
             /\ numof (inversion a1 i) i (#a1)
              = numof (inversion a1 i) i i0
              + numof (inversion a1 i) i0 (i0+1)
              + numof (inversion a1 i) (i0+1) (i0+2)
              + numof (inversion a1 i) (i0+2) (#a1)
             /\ numof (inversion a2 i) i0 (i0+1)
                = numof (inversion a1 i) (i0+1) (i0+2)
             /\ numof (inversion a2 i) (i0+1) (i0+2)
                = numof (inversion a1 i) i0 (i0+1)
             /\ numof (inversion a2 i) i i0 = numof (inversion a1 i) i i0
             /\ numof (inversion a2 i) (i0+2) (#a2)
                = numof (inversion a1 i) (i0+2) (#a1)
              };
    assert { forall i. i0 + 1 < i < #a1 ->
             inversions_for a2 i = inversions_for a1 i };
    assert { inversions_for a2 i0 = inversions_for a1 (i0+1)
             by numof (inversion a1 (i0+1)) (i0+2) (#a1)
              = numof (inversion a2 i0    ) (i0+2) (#a1) };
    assert { 1 + inversions_for a2 (i0+1) = inversions_for a1 i0
             by numof (inversion a1 i0) i0 (#a1)
              = numof (inversion a1 i0) (i0+1) (#a1)
              = 1 + numof (inversion a1 i0) (i0+2) (#a1)
              = 1 + numof (inversion a2 (i0+1)) (i0+2) (#a2) };
    let sum_decomp (a: array int) (i j k: int)
      requires { 0 <= i <= j <= k <= #a = #a1 }
      ensures  { sum (inversions_for a) i k =
                 sum (inversions_for a) i j + sum (inversions_for a) j k }
    = () in
    let decomp (a: array int)
      requires { #a = #a1 }
      ensures  { inversions a = sum (inversions_for a) 0 i0
                              + inversions_for a i0
                              + inversions_for a (i0+1)
                              + sum (inversions_for a) (i0+2) #a }
    = sum_decomp a 0 i0 (length a);
      sum_decomp a i0 (i0+1) (length a);
      sum_decomp a (i0+1) (i0+2) (length a);
    in
    decomp a1; decomp a2;
    ()

end
