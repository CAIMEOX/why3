
(** {1 Sequences}

    This file provides a basic theory of sequences.
*)

(** {2 Sequences and basic operations} *)

module Seq

  use map.Map
  use int.Int

  (** the polymorphic type of sequences *)
  type seq 'a

  (** `seq 'a` is an infinite type *)
  meta "infinite_type" type seq

  function (#_) (seq 'a) : int

  axiom length_nonnegative:
    forall s: seq 'a. 0 <= #s

  function get (seq 'a) : int -> 'a
  (** `get s i` is the `i+1`-th element of sequence `s`
      (the first element has index 0) *)

  function ([]) [@inline:trivial] (s: seq 'a) (i: int) : 'a = get s i

  (** equality *)
  predicate (==) (s1 s2: seq 'a)

  axiom eq_def:
    forall s1 s2: seq 'a.
    s1 == s2 <-> #s1 = #s2 /\ forall i. 0 <= i < #s1 -> s1[i] = s2[i]

  (** equality is extensional *)
  axiom eq_ext:
    forall s1, s2: seq 'a. s1 == s2 -> s1 = s2

  (** sequence comprehension *)
  function create (len: int) (f: int -> 'a) : seq 'a

  axiom create_length:
    forall len, f: int -> 'a. 0 <= len -> #(create len f) = len
  axiom create_contents:
    forall len, f: int -> 'a, i. 0 <= i < len -> (create len f)[i] = f i

  (*** FIXME: could be defined, but let constant does
     not accept spec. *)
  (*** let constant empty : seq 'a
    ensures { #result = 0 }
  = while false do variant { 0 } () done;
    create 0 (fun _ requires { false } -> absurd)
   *)

  (** empty sequence *)
  constant empty : seq 'a

  axiom empty_def: #(empty: seq 'a) = 0

  (** `set s i v` is a new sequence `u` such that
      `u[i] = v` and `u[j] = s[j]` otherwise *)
  function set (s: seq 'a) (i: int) (v: 'a) : seq 'a

  function ([<-]) (s: seq 'a) (i: int) (v: 'a) : seq 'a
  = set s i v

  axiom set_length:
    forall s: seq 'a, i, v. #(set s i v) = #s
  axiom set_contents:
    forall s: seq 'a, i, v. 0 <= i < #s ->
    get (set s i v) = Map.set (get s) i v
  lemma set_value:
    forall s: seq 'a, i, v. 0 <= i < #s -> (set s i v)[i] = v
  lemma set_other:
    forall s: seq 'a, i, v, j. 0 <= j < #s -> j <> i -> (set s i v)[j] = s[j]

  (** singleton sequence *)
  function singleton (v: 'a) : seq 'a

  axiom singleton_length:
    forall v: 'a. #(singleton v) = 1
  axiom singleton_element:
    forall v: 'a. (singleton v)[0] = v

  (** insertion of elements on both sides *)
  function cons (x: 'a) (s: seq 'a) : seq 'a

  axiom cons_length:
    forall s: seq 'a, x. #(cons x s) = 1 + #s
  axiom cons_head:
    forall s: seq 'a, x. (cons x s)[0] = x
  axiom cons_tail:
    forall s: seq 'a, x, i. 0 < i <= #s -> (cons x s)[i] = s[i-1]

  function snoc (s: seq 'a) (x: 'a) : seq 'a

  axiom snoc_length:
    forall s: seq 'a, x. #(snoc s x) = 1 + #s
  axiom snoc_last:
    forall s: seq 'a, x. (snoc s x)[#s] = x
  axiom snoc_init:
    forall s: seq 'a, x, i. 0 <= i < #s -> (snoc s x)[i] = s[i]

  (** `s[i..j]` is the slice of `s` from element `i` included
      to element `j` excluded *)
  function ([..]) (s: seq 'a) (i: int) (j: int) : seq 'a

  axiom slice_length:
    forall s: seq 'a, i, j. 0 <= i <= j <= #s -> #(s[i..j]) = j - i
  axiom slice_contents:
    forall s: seq 'a, i, j, k. 0 <= i <= j <= #s -> 0 <= k < j - i ->
    s[i..j][k] = s[i + k]

  function ([_..]) [@inline:trivial] (s: seq 'a) (i: int) : seq 'a
  = s[i .. #s]

  function ([.._]) [@inline:trivial] (s: seq 'a) (j: int) : seq 'a
  = s[0..j]

  lemma slice_full: forall s: seq 'a. s = s[0 .. #s]

  (** concatenation *)
  function (++) (s1: seq 'a) (s2: seq 'a) : seq 'a

  axiom append_length:
    forall s1 s2: seq 'a. #(s1 ++ s2) = #s1 + #s2
  axiom append_left:
    forall s1 s2: seq 'a, i. 0 <= i < #s1 -> (s1 ++ s2)[i] = s1[i]
  axiom append_right1:
    forall s1 s2: seq 'a, i. #s1 <= i < #s1 + #s2 -> (s1 ++ s2)[i] = s2[i - #s1]
  axiom append_right2:
    forall s1 s2: seq 'a, i. 0 <= i < #s2 -> (s1 ++ s2)[#s1 + i] = s2[i]

end

(** {2 Lemma library about algebraic interactions between
       `empty`/`singleton`/`cons`/`snoc`/`++`/`[ .. ]`} *)

module FreeMonoid

  use int.Int
  use Seq

  (* Monoidal properties/simplification. *)

  let lemma associative (s1 s2 s3:seq 'a)
    ensures { s1 ++ (s2 ++ s3) = (s1 ++ s2) ++ s3 }
  = if not (s1 ++ s2) ++ s3 == s1 ++ (s2 ++ s3) then absurd
  meta rewrite axiom associative

  let lemma left_neutral (s:seq 'a)
    ensures { empty ++ s = s }
  = if not empty ++ s == s then absurd
  meta rewrite axiom left_neutral

  let lemma right_neutral (s:seq 'a)
    ensures { s ++ empty = s }
  = if not s ++ empty == s then absurd
  meta rewrite axiom right_neutral

  let lemma cons_def (x:'a) (s:seq 'a)
    ensures { cons x s = singleton x ++ s }
  = if not cons x s == singleton x ++ s then absurd
  meta rewrite axiom cons_def

  let lemma snoc_def (s:seq 'a) (x:'a)
    ensures { snoc s x = s ++ singleton x }
  = if not snoc s x == s ++ singleton x then absurd
  meta rewrite axiom snoc_def

  let lemma double_sub_sequence (s:seq 'a) (i j k l:int)
    requires { 0 <= i <= j <= #s }
    requires { 0 <= k <= l <= j - i }
    ensures { s[i..j][k..l] = s[k+i..l+i] }
  = if not s[i..j][k..l] == s[k+i..l+i] then absurd

  (* Inverting cons/snoc/catenation *)

  let lemma cons_back (x:'a) (s:seq 'a)
    ensures { (cons x s)[1..] = s }
  = if not (cons x s)[1..] == s then absurd

  let lemma snoc_back (s:seq 'a) (x:'a)
    ensures { (snoc s x)[.. #s] = s }
  = if not (snoc s x)[.. #s] == s then absurd

  let lemma cat_back (s1 s2:seq 'a)
    ensures { (s1 ++ s2)[.. #s1] = s1 }
    ensures { (s1 ++ s2)[#s1..] = s2 }
  = let c = s1 ++ s2 in let l = #s1 in
    if not (c[..l] == s1 || c[l..] == s2) then absurd

  (* Decomposing sequences as cons/snoc/catenation/empty/singleton *)

  let lemma cons_dec (s:seq 'a)
    requires { #s >= 1 }
    ensures  { s = cons s[0] s[1..] }
  = if not s == cons s[0] s[1..] then absurd

  let lemma snoc_dec (s:seq 'a)
    requires { #s >= 1 }
    ensures  { s = snoc s[.. #s - 1] s[#s - 1] }
  = if not s == snoc s[.. #s - 1] s[#s - 1] then absurd

  let lemma cat_dec (s:seq 'a) (i:int)
    requires { 0 <= i <= #s }
    ensures  { s = s[..i] ++ s[i..] }
  = if not s == s[..i] ++ s[i..] then absurd

  let lemma empty_dec (s:seq 'a)
    requires { #s = 0 }
    ensures  { s = empty }
  = if not s == empty then absurd

  let lemma singleton_dec (s:seq 'a)
    requires { #s = 1 }
    ensures  { s = singleton s[0] }
  = if not s == singleton s[0] then absurd

end

module ToList
  use int.Int
  use Seq
  use list.List

  val function to_list (a: seq 'a) : list 'a

  axiom to_list_empty:
    to_list (empty: seq 'a) = (Nil: list 'a)

  axiom to_list_cons:
    forall s: seq 'a. 0 < #s ->
    to_list s = Cons s[0] (to_list s[1..])

  use list.Length as ListLength

  lemma to_list_length:
    forall s: seq 'a. ListLength.length (to_list s) = #s

  use list.Nth as ListNth
  use option.Option

  lemma to_list_nth:
    forall s: seq 'a, i: int. 0 <= i < #s ->
    ListNth.nth i (to_list s) = Some s[i]

  let rec lemma to_list_def_cons (s: seq 'a) (x: 'a)
    variant { #s }
    ensures { to_list (cons x s) = Cons x (to_list s) }
  = assert { (cons x s)[1..] == s }

end

module OfList
  use int.Int
  use option.Option
  use list.List
  use list.Length as L
  use list.Nth
  use Seq
  use list.Append

  function of_list (l: list 'a) : seq 'a = match l with
    | Nil -> empty
    | Cons x r -> cons x (of_list r)
    end

  lemma length_of_list:
    forall l: list 'a. #(of_list l) = L.length l

  predicate point_wise (s: seq 'a) (l: list 'a) =
    forall i. 0 <= i < L.length l -> Some (get s i) = nth i l

  lemma elts_seq_of_list: forall l: list 'a.
    point_wise (of_list l) l

  lemma is_of_list: forall l: list 'a, s: seq 'a.
    L.length l = #s -> point_wise s l -> s == of_list l

  let rec lemma of_list_app (l1 l2: list 'a)
    ensures { of_list (l1 ++ l2) == Seq.(++) (of_list l1) (of_list l2) }
    variant { l1 }
  = match l1 with
    | Nil -> ()
    | Cons _ r -> of_list_app r l2
    end

  lemma of_list_app_length: forall l1 [@induction] l2: list 'a.
    #(of_list (l1 ++ l2)) = L.length l1 + L.length l2

  let rec lemma of_list_snoc (l: list 'a) (x: 'a)
    variant { l }
    ensures { of_list (l ++ Cons x Nil) == snoc (of_list l) x }
  = match l with
    | Nil -> assert { snoc empty x = cons x empty }
    | Cons _ r -> of_list_snoc r x;
    end

  meta coercion function of_list

  use ToList

  lemma convolution_to_of_list: forall l: list 'a.
    to_list (of_list l) = l

end

(* TODO could be defined as occ x s > 0 *)
module Mem

  use int.Int
  use Seq

  predicate mem (x: 'a) (s: seq 'a) =
    exists i: int. 0 <= i < #s && s[i] = x

  lemma mem_append : forall x: 'a, s1 s2.
    mem x (s1 ++ s2) <-> mem x s1 \/ mem x s2

  lemma mem_tail: forall x: 'a, s.
    #s > 0 ->
    mem x s <-> (x = s[0] \/ mem x s[1..])

end

module Distinct
  use int.Int
  use Seq

  predicate distinct (s : seq 'a) =
    forall i j. 0 <= i < #s -> 0 <= j < #s ->
    i <> j -> s[i] <> s[j]

end

module Reverse

  use int.Int
  use Seq

  function reverse (s: seq 'a) : seq 'a =
    create #s (fun i -> s[#s - 1 - i])

end

module ToFset
  use int.Int
  use set.Fset
  use Mem
  use Seq

  val function to_set (s: seq 'a) : fset 'a

  axiom to_set_empty: to_set (empty: seq 'a) = (Fset.empty: fset 'a)

  axiom to_set_add: forall s: seq 'a. #s > 0 ->
    to_set s = add s[0] (to_set s[1..])

  lemma to_set_cardinal: forall s: seq 'a.
    cardinal (to_set s) <= #s

  lemma to_set_mem: forall s: seq 'a, e: 'a.
    mem e s <-> Fset.mem e (to_set s)

  lemma to_set_snoc: forall s: seq 'a, x: 'a.
    to_set (snoc s x) = add x (to_set s)

  use Distinct

  lemma to_set_cardinal_distinct: forall s: seq 'a. distinct s ->
    cardinal (to_set s) = #s

end

(** {2 Sorted Sequences} *)

module Sorted

  use int.Int
  use Seq

  type t

  predicate rel t t
  (** the order relation to compare elements; can be strict or large *)

  predicate sorted (s: seq t) = forall i1 i2.
    0 <= i1 < i2 < #s -> rel s[i1] s[i2]
  (** `sorted s` is true whenever the sequence `s` is sorted w.r.t `rel`  *)

  lemma sorted_cons: forall x: t, s: seq t.
    (forall i. 0 <= i < #s -> rel x s[i]) /\ sorted s <->
    sorted (cons x s)

  lemma sorted_snoc: forall x: t, s: seq t.
    (forall i. 0 <= i < #s -> rel s[i] x) /\ sorted s <->
    sorted (snoc s x)

  lemma sorted_init: forall s: seq t. #s > 0 ->
    (forall i. 0 <= i < #s - 1 -> rel s[i] s[#s - 1]) /\ sorted s[.. #s-1] <->
    sorted s

  lemma sorted_tail: forall s: seq t. #s > 0 ->
    (forall i. 1 <= i < #s -> rel s[0] s[i]) /\ sorted s[1..] <->
    sorted s

  lemma sorted_slice_empty:
    forall s i. 0 <= i <= #s -> sorted s[i..i]

  lemma sorted_slice_init: forall s: seq t, i j. 0 <= i <= j < #s ->
    (forall k. i <= k < j -> rel s[k] s[j]) /\ sorted s[i..j] <->
    sorted s[i..j+1]

  lemma sorted_slice_tail: forall s: seq t, i j. 0 <= i < j <= #s ->
    (forall k. i+1 <= k < j -> rel s[i] s[k]) /\ sorted s[i+1..j] <->
    sorted s[i..j]

  lemma sorted_slide_mid: forall s: seq t, i j k. 0 <= i <= k <= j <= #s ->
    (sorted s[i..k] /\ sorted s[k..j] /\
      (forall m n. i <= m < k /\ k <= n < j -> rel s[m] s[n])) <->
    sorted s[i..j]

  lemma sorted_append: forall s1 s2: seq t.
    (sorted s1 /\ sorted s2 /\
      (forall i j. 0 <= i < #s1 /\ 0 <= j < #s2 -> rel s1[i] s2[j])) <->
    sorted (s1 ++ s2)

  lemma sorted_equiv: forall s1 s2.
    s1 == s2 -> sorted s1 <-> sorted s2

end

module SortedInt (** sorted sequences of integers *)

  use int.Int

  clone export Sorted with type t = int, predicate rel = (<=), goal .

end

module Sum

  use int.Int
  use Seq
  use int.Sum as S

  function sum (s: seq int) : int = S.sum (get s) 0 #s

  lemma sum_cons:
    forall s x. sum (cons x s) = x + sum s

  lemma sum_snoc:
    forall s x. sum (snoc s x) = sum s + x

  lemma sum_init:
    forall s. #s > 0 -> sum s = sum s[.. #s - 1] + s[#s - 1]

  lemma sum_tail:
    forall s. #s > 0 -> sum s = s[0] + sum s[1..]

  lemma sum_slice_empty:
    forall s i. 0 <= i <= #s -> sum s[i..i] = 0

  lemma sum_slice_init: forall s i j. 0 <= i <= j < #s ->
    sum s[i..j+1] = sum s[i..j] + s[j]

  lemma sum_slice_tail: forall s i j. 0 <= i < j <= #s ->
    sum s[i..j] = s[i] + sum s[i+1..j]

  lemma sum_slice_mid: forall s i j k. 0 <= i <= k <= j <= #s ->
    sum s[i..j] = sum s[i..k] + sum s[k..j]

  lemma sum_append:
    forall s1 s2.
    sum (s1 ++ s2) = sum s1 + sum s2

  lemma sum_equiv:
    forall s1 s2.
    s1 == s2 -> sum s1 = sum s2

end

module NumOfIndex

  use int.Int
  use int.NumOf as N
  use Seq

  function is_true_i (p: int -> 'a -> bool) (s: seq 'a) : int -> bool =
    fun i -> p i s[i]

  function numof_i (p: int -> 'a -> bool) (s: seq 'a) : int
    = N.numof (is_true_i p s) 0 #s

end

module NumOf

  use int.Int
  use int.NumOf as N
  use Seq

  function is_true (p: 'a -> bool) (s: seq 'a) : int -> bool =
    fun i -> p s[i]

  function numof (p: 'a -> bool) (s: seq 'a) : int
    = N.numof (is_true p s) 0 #s

  lemma numof_cons: forall p, s: seq 'a, x: 'a.
    numof p (cons x s) = if p x then 1 + numof p s else numof p s

  lemma numof_snoc: forall p, s: seq 'a, x: 'a.
    numof p (snoc s x) = if p x then 1 + numof p s else numof p s

  lemma numof_init: forall p, s: seq 'a. #s > 0 ->
    numof p s[.. #s-1] = if p s[#s-1] then numof p s - 1 else numof p s

  lemma numof_tail: forall p, s: seq 'a. #s > 0 ->
    numof p s[1..] = if p s[0] then numof p s - 1 else numof p s

  lemma numof_slice_empty:
    forall p, s: seq 'a, i. 0 <= i <= #s -> numof p s[i..i] = 0

  lemma numof_slice_init: forall p, s: seq 'a, i j. 0 <= i <= j < #s ->
    numof p s[i..j+1] = if p s[j] then numof p s[i..j] + 1
                                  else numof p s[i..j]

  lemma numof_slice_tail: forall p, s: seq 'a, i j. 0 <= i < j <= #s ->
    numof p s[i..j] = if p s[i] then 1 + numof p s[i+1..j]
                                else     numof p s[i+1..j]

  lemma numof_slice_mid: forall p, s: seq 'a, i j k. 0 <= i <= k <= j <= #s ->
    numof p s[i..j] = numof p s[i..k] + numof p s[k..j]

  lemma numof_append: forall p, s1 s2: seq 'a.
    numof p (s1 ++ s2) = numof p s1 + numof p s2

  lemma numof_equiv: forall s1 s2: seq 'a, p.
    s1 == s2 -> numof p s1 = numof p s2

  lemma numof_exchange: forall p, s: seq 'a, i j: int, x y: 'a.
    0 <= i < #s -> 0 <= j < #s -> i <> j ->
    numof p s[i <- x][j <- y] =
    numof p s[i <- y][j <- x]

  lemma numof_slice_extend: forall p, s: seq 'a, i j k l.
    0 <= k <= i <= j <= l <= #s -> numof p s[i..j] <= numof p s[k..l]

  lemma numof_extend: forall p, s: seq 'a, i j. 0 <= i < j <= #s ->
    numof p s[i..j] <= numof p s

end

(** {2 Number of occurences in a sequence} *)

(* TODO define occ using numof? (drawback: two lambdas) *)
module Occ

  use int.Int
  use int.NumOf
  use Seq

  function is_eq (x: 'a) (s: seq 'a) : int -> bool = fun i -> s[i] = x

  function occ (x: 'a) (s: seq 'a) : int = numof (is_eq x s) 0 #s

  lemma occ_cons: forall v: 'a, s: seq 'a, x: 'a.
    occ v (cons x s) = if v = x then 1 + occ v s else occ v s

  lemma occ_snoc: forall v: 'a, s: seq 'a, x: 'a.
    occ v (snoc s x) = if v = x then 1 + occ v s else occ v s

  lemma occ_init: forall v: 'a, s: seq 'a. #s > 0 ->
    occ v s[.. #s-1] = if v = s[#s-1] then occ v s - 1 else occ v s

  lemma occ_tail: forall v: 'a, s: seq 'a. #s > 0 ->
    occ v s[1..] = if v = s[0] then occ v s - 1 else occ v s

  lemma occ_slice_empty: forall v: 'a, s i. 0 <= i <= #s ->
    occ v s[i..i] = 0

  lemma occ_slice_init: forall v: 'a, s: seq 'a, i j. 0 <= i <= j < #s ->
    occ v s[i..j+1] = if v = s[j] then occ v s[i..j] + 1 else occ v s[i..j]

  lemma occ_slice_tail: forall v: 'a, s: seq 'a, i j. 0 <= i < j <= #s ->
    occ v s[i..j] = if v = s[i] then 1 + occ v s[i+1..j] else occ v s[i+1..j]

  lemma occ_slice_mid: forall v: 'a, s: seq 'a, i j k. 0 <= i <= k <= j <= #s ->
    occ v s[i..j] = occ v s[i..k] + occ v s[k..j]

  lemma occ_append: forall v: 'a, s1 s2: seq 'a.
    occ v (s1 ++ s2) = occ v s1 + occ v s2

  lemma occ_equiv: forall s1 s2: seq 'a, v: 'a.
    s1 == s2 -> occ v s1 = occ v s2

  lemma occ_pos: forall s: seq 'a, i: int.
    0 <= i < #s -> occ s[i] s > 0

  lemma occ_exchange:
    forall s: seq 'a, i j: int, x y z: 'a.
    0 <= i < #s -> 0 <= j < #s -> i <> j ->
    occ z s[i <- x][j <- y] =
    occ z s[i <- y][j <- x]

  lemma occ_slice_extend: forall v, s: seq 'a, i j k l.
    0 <= k <= i <= j <= l <= #s -> occ v s[i..j] <= occ v s[k..l]

  lemma occ_extend: forall v, s: seq 'a, i j. 0 <= i < j <= #s ->
    occ v s[i..j] <= occ v s

end

(* TODO defined using map.Exchange? *)
module Exchange

  use int.Int
  use Seq

  predicate exchange (s1 s2: seq 'a) (i j: int) =
    #s1 = #s2 /\
    0 <= i < #s1 /\ 0 <= j < #s1 /\
    s1[i] = s2[j] /\ s1[j] = s2[i] /\
    (forall k:int. 0 <= k < #s1 -> k <> i -> k <> j -> s1[k] = s2[k])

  lemma exchange_set:
    forall s: seq 'a, i j: int.
    0 <= i < #s -> 0 <= j < #s ->
    exchange s s[i <- s[j]][j <- s[i]] i j

end

(** {2 Permutation of sequences} *)

module Permut

  use int.Int
  use Seq
  use Occ
  use export Exchange

  predicate permut (s1 s2: seq 'a) =
    #s1 = #s2 /\ forall v: 'a. occ v s1 = occ v s2
  (** `permut s1 s2` is true when
      sequence `s1` is a permutation of sequence `s2` *)

  predicate permut_sub (s1 s2: seq 'a) (l u: int) =
    0 <= l <= u <= #s1 = #s2 /\
    s1[..l] == s2[..l] /\
    permut s1[l..u] s2[l..u] /\
    s1[u..] == s2[u..]
  (** `permut_sub s1 s2 l u` is true when the segment
      `s1[l..u-1]` is a permutation of the segment `s2[l..u-1]`
      and values outside of this range are equal. *)

  lemma exchange_permut_sub: forall s1 s2: seq 'a, i j l u: int.
    exchange s1 s2 i j -> l <= i < u -> l <= j < u -> 0 <= l -> u <= #s1 ->
    permut_sub s1 s2 l u

  (** enlarge the interval *)
  lemma permut_sub_weakening: forall s1 s2: seq 'a, l1 u1 l2 u2: int.
    permut_sub s1 s2 l1 u1 -> 0 <= l2 <= l1 -> u1 <= u2 <= #s1 ->
    permut_sub s1 s2 l2 u2

  (** {3 Lemmas about permut} *)

  lemma permut_refl: forall s: seq 'a.
    permut s s

  lemma permut_sym: forall s1 s2: seq 'a.
    permut s1 s2 -> permut s2 s1

  lemma permut_trans: forall s1 s2 s3: seq 'a.
    permut s1 s2 -> permut s2 s3 -> permut s1 s3

  lemma permut_exists: forall s1 s2: seq 'a, i: int.
    permut s1 s2 -> 0 <= i < #s2 ->
    exists j: int. 0 <= j < #s1 /\ s1[j] = s2[i]

  lemma permut_sub_permut: forall s1 s2: seq 'a, l u: int.
    permut_sub s1 s2 l u -> permut s1 s2

  lemma exchange_permut: forall s1 s2: seq 'a, i j: int.
    exchange s1 s2 i j -> permut s1 s2

end

module FoldLeft

  use Seq
  use int.Int

  (** `fold_left f a [b1; ...; bn]` is `f (... (f (f a b1) b2) ...) bn` *)
  let rec ghost function fold_left (f: 'a -> 'b -> 'a) (acc: 'a) (s: seq 'b) : 'a
    variant { #s }
  = if #s = 0 then acc else fold_left f (f acc s[0]) s[1..]

  lemma fold_left_ext: forall f: 'b -> 'a -> 'b, acc: 'b, s1 s2: seq 'a.
    s1 == s2 -> fold_left f acc s1 = fold_left f acc s2

  lemma fold_left_cons: forall s: seq 'a, x: 'a, f: 'b -> 'a -> 'b, acc: 'b.
    fold_left f acc (cons x s) = fold_left f (f acc x) s

  let rec lemma fold_left_app (s1 s2: seq 'a) (f: 'b -> 'a -> 'b) (acc: 'b)
    ensures { fold_left f acc (s1 ++ s2) = fold_left f (fold_left f acc s1) s2 }
    variant { #s1 }
  = if #s1 > 0 then fold_left_app s1[1..] s2 f (f acc s1[0])

end

module FoldRight

  use Seq
  use int.Int

  (** `fold_right f [a1; ...; an] b` is `f a1 (f a2 (... (f an b) ...))` *)
  let rec ghost function fold_right (f: 'b -> 'a -> 'a) (s: seq 'b) (acc: 'a) : 'a
    variant { #s }
  = if #s = 0 then acc else fold_right f s[.. #s - 1] (f s[#s - 1] acc)

  lemma fold_right_ext: forall f: 'a -> 'b -> 'b, acc: 'b, s1 s2: seq 'a.
    s1 == s2 -> fold_right f s1 acc = fold_right f s2 acc

  lemma fold_right_snoc: forall s: seq 'a, x: 'a, f: 'a -> 'b -> 'b, acc: 'b.
    fold_right f (snoc s x) acc = fold_right f s (f x acc)

  let rec lemma fold_right_app (s1 s2: seq 'a) (f: 'a -> 'b -> 'b) (acc: 'b)
    ensures { fold_right f (s1 ++ s2) acc = fold_right f s1 (fold_right f s2 acc) }
    variant { #s2 }
  = if #s2 > 0 then fold_right_app s1 s2[.. #s2 - 1] f (f s2[#s2 - 1] acc)

end

(*** TODO / TO DISCUSS

  - what about s[i..j] when i..j is not a valid range?
    left undefined? empty sequence?

  - what about negative index e.g. s[-3..] for the last three elements?

  - a syntax for cons and snoc?

  - create: better name? move to a separate theory?

  - UNPLEASANT: we cannot write s[..#s-1] because ..# is recognized as a lexeme

  - UNPLEASANT: when using both arrays and sequences, the lack of overloading
    is a pain; see for instance vstte12_ring_buffer.mlw

*)
