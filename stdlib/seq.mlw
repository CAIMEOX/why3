(** {1 Sequences}

    This file provides a basic theory of sequences.
*)

(** {2 Sequences and basic operations} *)

module Seq

  use int.Int

  (** the polymorphic type of sequences *)
  type seq 'a

  (** `seq 'a` is an infinite type *)
  meta "infinite_type" type seq

  val function length (seq 'a) : int
  axiom length_nonnegative:
    forall s: seq 'a. 0 <= length s

  val function get (seq 'a) int : 'a
  (** `get s i` is the `i+1`-th element of sequence `s`
      (the first element has index 0) *)

  let function ([]) (s: seq 'a) (i: int) : 'a
  = [@inline:trivial]
    get s i

  (** equality is extensional *)
  val ghost predicate (==) (s1 s2: seq 'a)
    ensures { result <-> length s1 = length s2 &&
              forall i: int. 0 <= i < length s1 -> s1[i] = s2[i] }
    ensures { result -> s1 = s2 }

  (** sequence comprehension *)
  val function create (len: int) (f: int -> 'a) : seq 'a
    requires { 0 <= len }
    ensures { length result = len }
    ensures { forall i. 0 <= i < len -> result[i] = f i }

  (*** FIXME: could be defined, but let constant does
     not accept spec. *)
  (*** let constant empty : seq 'a
    ensures { length result = 0 }
  = let function f () = () in
    create 0 (fun _ requires { false } -> absurd)
   *)

  (** empty sequence *)
  val constant empty : seq 'a
    ensures { length result = 0 }

  (** `set s i v` is a new sequence `u` such that
      `u[i] = v` and `u[j] = s[j]` otherwise.
      If i is out of bounds, the result is the input sequence. *)
  let function set (s:seq 'a) (i:int) (v:'a) : seq 'a
    ensures { length result = length s }
    ensures { not (0 <= i < length s) -> result = s }
    ensures { 0 <= i < length s -> result[i] = v }
    ensures { forall j. 0 <= j < length s /\ j <> i -> result[j] = s[j] }
  = let function f () = () in
    create s.length (fun j -> if j = i then v else s[j])

  let function ([<-]) (s: seq 'a) (i: int) (v: 'a) : seq 'a
  = [@inline:trivial]
    set s i v

  (** singleton sequence *)
  let function singleton (v:'a) : seq 'a
    ensures { length result = 1 }
    ensures { result[0] = v }
  = let function f () = () in
    create 1 (fun _ -> v)

  (** concatenation *)
  let function (++) (s1:seq 'a) (s2:seq 'a) : seq 'a
    ensures { length result = length s1 + length s2 }
    ensures { forall i. 0 <= i < length s1 -> result[i] = s1[i] }
    ensures { forall i. length s1 <= i < length result -> result[i] = s2[i - length s1] }
  = let function f () = () in
    let l = length s1 in
    create (l + length s2)
           (fun i -> if i < l then s1[i] else s2[i-l])

  (** insertion of elements on both sides *)
  let function cons (x:'a) (s:seq 'a) : seq 'a
    ensures { length result = 1 + length s }
    ensures { result[0] = x }
    ensures { forall i. 0 < i <= length s -> result[i] = s[i-1] }
  = let function f () = () in
    singleton x ++ s

  let function snoc (s:seq 'a) (x:'a) : seq 'a
    ensures { length result = 1 + length s }
    ensures { result[length s] = x }
    ensures { forall i. 0 <= i < length s -> result[i] = s[i] }
  = let function f () = () in
    s ++ singleton x

  (** s`i..j` extract subsequence between indices `i` (included) and
      `j` (excluded).

      If `i` is out of bounds or `j < i`, then returns the empty sequence.
      If `j > length s`, then the resulting sequence is truncated. *)
  let function ([..]) (s:seq 'a) (i:int) (j:int) : seq 'a
    ensures { i < 0 \/ length s <= i -> result = empty }
    ensures { j <= i -> result = empty }
    ensures { 0 <= i <= j <= length s -> length result = j - i }
    ensures { 0 <= i <= length s <= j -> length result = length s - i }
    ensures { forall k. 0 <= k < length result -> result[k] = s[i+k] }
  = let function f () = () in
    if i < 0 || i > length s || j < i then empty
    else begin
      create (if j <= length s then j - i else length s - i) (fun k -> s[i+k])
    end

  function smt_extract (s:seq 'a) (i:int) (j:int) : seq 'a
  axiom smt_extract_spec :
    forall s: seq 'a, i j: int. s[i..j] = smt_extract s i (j-i)

  let function ([_..]) (s: seq 'a) (i: int) : seq 'a
  = [@inline:trivial]
    s[i .. length s]

  let function ([.._]) (s: seq 'a) (j: int) : seq 'a
  = [@inline:trivial]
    s[0 .. j]

end

(** {2 Lemma library about algebraic interactions between
       `empty`/`singleton`/`cons`/`snoc`/`++`/`[ .. ]`} *)

module FreeMonoid

  use int.Int
  use Seq

  (* Monoidal properties/simplification. *)

  let lemma associative (s1 s2 s3:seq 'a)
    ensures { s1 ++ (s2 ++ s3) = (s1 ++ s2) ++ s3 }
  = if not (s1 ++ s2) ++ s3 == s1 ++ (s2 ++ s3) then absurd
  meta rewrite axiom associative

  let lemma left_neutral (s:seq 'a)
    ensures { empty ++ s = s }
  = if not empty ++ s == s then absurd
  meta rewrite axiom left_neutral

  let lemma right_neutral (s:seq 'a)
    ensures { s ++ empty = s }
  = if not s ++ empty == s then absurd
  meta rewrite axiom right_neutral

  let lemma cons_def (x:'a) (s:seq 'a)
    ensures { cons x s = singleton x ++ s }
  = if not cons x s == singleton x ++ s then absurd
  meta rewrite axiom cons_def

  let lemma snoc_def (s:seq 'a) (x:'a)
    ensures { snoc s x = s ++ singleton x }
  = if not snoc s x == s ++ singleton x then absurd
  meta rewrite axiom snoc_def

  let lemma double_sub_sequence (s:seq 'a) (i j k l:int)
    requires { 0 <= i <= j <= length s }
    requires { 0 <= k <= l <= j - i }
    ensures { s[i .. j][k .. l] = s[k+i .. l+i] }
  = if not s[i .. j][k .. l] == s[k+i .. l+i] then absurd

  (* Inverting cons/snoc/catenation *)

  let lemma cons_back (x:'a) (s:seq 'a)
    ensures { (cons x s)[1..] = s }
  = if not (cons x s)[1..] == s then absurd

  let lemma snoc_back (s:seq 'a) (x:'a)
    ensures { (snoc s x)[.. length s] = s }
  = if not (snoc s x)[.. length s] == s then absurd

  let lemma cat_back (s1 s2:seq 'a)
    ensures { (s1 ++ s2)[.. length s1] = s1 }
    ensures { (s1 ++ s2)[length s1 ..] = s2 }
  = let c = s1 ++ s2 in let l = length s1 in
    if not (c[.. l] == s1 || c[l ..] == s2) then absurd

  (* Decomposing sequences as cons/snoc/catenation/empty/singleton *)

  let lemma cons_dec (s:seq 'a)
    requires { length s >= 1 }
    ensures  { s = cons s[0] s[1..] }
  = if not s == cons s[0] s[1..] then absurd

  let lemma snoc_dec (s:seq 'a)
    requires { length s >= 1 }
    ensures  { s = snoc s[.. length s - 1] s[length s - 1] }
  = if not s == snoc s[.. length s - 1] s[length s - 1] then absurd

  let lemma cat_dec (s:seq 'a) (i:int)
    requires { 0 <= i <= length s }
    ensures  { s = s[.. i] ++ s[i ..] }
  = if not s == s[.. i] ++ s[i ..] then absurd

  let lemma empty_dec (s:seq 'a)
    requires { length s = 0 }
    ensures  { s = empty }
  = if not s == empty then absurd

  let lemma singleton_dec (s:seq 'a)
    requires { length s = 1 }
    ensures  { s = singleton s[0] }
  = if not s == singleton s[0] then absurd

end

module ToList
  use int.Int
  use Seq
  use list.List

  val function to_list (a: seq 'a) : list 'a

  axiom to_list_empty:
    to_list (empty: seq 'a) = (Nil: list 'a)

  axiom to_list_cons:
    forall s: seq 'a. 0 < length s ->
    to_list s = Cons s[0] (to_list s[1..])

  use list.Length as ListLength

  let rec lemma to_list_length (s: seq 'a)
    variant { length s }
    ensures { ListLength.length (to_list s) = length s }
  = if length s > 0 then to_list_length s[1..] else assert { s == empty }

  use list.Nth as ListNth
  use option.Option

  let rec lemma to_list_nth (s: seq 'a) (i: int)
    variant { i }
    requires { 0 <= i < length s }
    ensures { ListNth.nth i (to_list s) = Some s[i] }
  = if i = 0 then () else to_list_nth s[1..] (i-1)

  let rec lemma to_list_def_cons (s: seq 'a) (x: 'a)
    variant { length s }
    ensures { to_list (cons x s) = Cons x (to_list s) }
  = assert { (cons x s)[1..] == s }

end

module OfList
  use int.Int
  use option.Option
  use list.List
  use list.Length as L
  use list.Nth
  use Seq
  use list.Append

  let rec function of_list (l: list 'a) : seq 'a = match l with
    | Nil -> empty
    | Cons x r -> cons x (of_list r)
    end

  let rec lemma length_of_list (l: list 'a)
    ensures { length (of_list l) = L.length l }
  = match l with
    | Nil -> ()
    | Cons _ r -> length_of_list r
    end

  predicate point_wise (s: seq 'a) (l: list 'a) =
    forall i. 0 <= i < L.length l -> Some (get s i) = nth i l

  let rec lemma elts_seq_of_list (l: list 'a)
    ensures { point_wise (of_list l) l }
  = match l with
    | Nil -> ()
    | Cons _ r -> elts_seq_of_list r
    end

  lemma is_of_list: forall l: list 'a, s: seq 'a.
    L.length l = length s -> point_wise s l -> s == of_list l

  let rec lemma of_list_app (l1 l2: list 'a)
    ensures { of_list (l1 ++ l2) == Seq.(++) (of_list l1) (of_list l2) }
    variant { l1 }
  = match l1 with
    | Nil -> ()
    | Cons _ r -> of_list_app r l2
    end

  lemma of_list_app_length: forall l1 l2: list 'a.
    length (of_list (l1 ++ l2)) = L.length l1 + L.length l2

  let rec lemma of_list_snoc (l: list 'a) (x: 'a)
    variant { l }
    ensures { of_list (l ++ Cons x Nil) == snoc (of_list l) x }
  = match l with
    | Nil -> assert { snoc empty x == cons x empty }
    | Cons _ r -> of_list_snoc r x;
    end

  meta coercion function of_list

  use ToList

  lemma convolution_to_of_list: forall l: list 'a.
    to_list (of_list l) = l

end

module Mem

  use int.Int
  use Seq

  predicate mem (x: 'a) (s: seq 'a) =
    exists i: int. 0 <= i < length s && s[i] = x

  lemma mem_append : forall x: 'a, s1 s2.
    mem x (s1 ++ s2) <-> mem x s1 \/ mem x s2

  let lemma mem_tail (x: 'a) (s: seq 'a)
    requires { length s > 0 }
    ensures { mem x s <-> (x = s[0] \/ mem x s[1.. ]) }
  = assert { s == singleton s[0] ++ s[1..] }

end

module Distinct
  use int.Int
  use Seq

  predicate distinct (s : seq 'a) =
    forall i j. 0 <= i < length s -> 0 <= j < length s ->
    i <> j -> s[i] <> s[j]

end

module Reverse

  use int.Int
  use Seq

  let function reverse (s: seq 'a) : seq 'a =
    create (length s) (fun i -> s[length s - 1 - i])

end

module ToFset
  use int.Int
  use set.Fset
  use Mem
  use Seq

  val function to_set (s: seq 'a) : fset 'a

  axiom to_set_empty: to_set (empty: seq 'a) = (Fset.empty: fset 'a)

  axiom to_set_add: forall s: seq 'a. length s > 0 ->
    to_set s = add s[0] (to_set s[1..])

  let rec lemma to_set_cardinal (s: seq 'a)
    variant { length s }
    ensures { cardinal (to_set s) <= length s }
  = if length s = 0 then assert { s == empty } else to_set_cardinal s[1..]

  let rec lemma to_set_mem (s: seq 'a) (e: 'a)
    variant { length s }
    ensures { mem e s <-> Fset.mem e (to_set s) }
  = if length s > 0 then to_set_mem s[1 ..] e

  let rec lemma to_set_snoc (s: seq 'a) (x: 'a)
    variant { length s }
    ensures { to_set (snoc s x) = add x (to_set s) }
  = if length s > 0 then
      to_set_snoc s[1..] x;
      assert { Fset.(==) (to_set (snoc s x)) (add x (to_set s)) }

  use Distinct

  let rec lemma to_set_cardinal_distinct (s: seq 'a)
    variant { length s }
    requires { distinct s }
    ensures { cardinal (to_set s) = length s }
  = if length s > 0 then to_set_cardinal_distinct s[1..]

end

(** {2 Sorted Sequences} *)

module Sorted

  use int.Int
  use Seq

  type t
  predicate le t t
  clone relations.TotalPreOrder as TO with
    type t = t, predicate rel = le, axiom .

  predicate sorted_sub (s: seq t) (l u: int) =
    forall i1 i2. l <= i1 <= i2 < u -> le s[i1] s[i2]
  (** `sorted_sub s l u` is true whenever the sub-sequence `s[l .. u-1]` is
      sorted  w.r.t. order relation `le` *)

  predicate sorted (s: seq t) =
    sorted_sub s 0 (length s)
  (** `sorted s` is true whenever the sequence `s` is sorted w.r.t `le`  *)

  let lemma sorted_cons (x: t) (s: seq t)
    ensures {
      (forall i: int. 0 <= i < length s -> le x s[i]) /\ sorted s <->
      sorted (cons x s)
    }
   = assert { forall i. 0 <= i < length s -> s[i] = (cons x s)[i+1] }

  lemma sorted_append:
    forall s1 s2: seq t.
    (sorted s1 /\ sorted s2 /\
      (forall i j: int. 0 <= i < length s1 /\ 0 <= j < length s2 ->
      le s1[i] s2[j])) <-> sorted (s1 ++ s2)

  lemma sorted_snoc:
    forall x: t, s: seq t.
      (forall i: int. 0 <= i < length s -> le s[i] x) /\ sorted s <->
    sorted (snoc s x)

end

module SortedInt (** sorted sequences of integers *)

  use int.Int
  clone export Sorted with type t = int, predicate le = (<=), goal .

end

module Sum

  use int.Int
  use Seq
  use int.Sum as S

  function sum (s: seq int) : int = S.sum (fun i -> s[i]) 0 (length s)

  lemma sum_snoc:
    forall s x. sum (snoc s x) = sum s + x
  lemma sum_tail:
    forall s. length s >= 1 -> sum s = s[0] + sum s[1 .. ]
  lemma sum_tail_tail:
    forall s. length s >= 2 -> sum s = s[0] + s[1] + sum s[2 .. ]

end

(** {2 Number of occurences in a sequence} *)

module Occ

  use int.Int
  use int.NumOf as N
  use Seq

  function iseq (x: 'a) (s: seq 'a) : int->bool = fun i -> s[i] = x

  function occ (x: 'a) (s: seq 'a) (l u: int) : int = N.numof (iseq x s) l u

  function occ_all (x: 'a) (s: seq 'a) : int =
    occ x s 0 (length s)

  let lemma occ_snoc (k: 'a) (s: seq 'a) (x: 'a)
    ensures { occ_all k (snoc s x) = if k = x then 1 + occ_all k s else occ_all k s }
  = assert { occ_all k s = occ k (snoc s x) 0 (length s) }

  let rec lemma occ_append (k: 'a) (s1 s2: seq 'a)
    ensures { occ_all k (s1 ++ s2) = occ_all k s1 + occ_all k s2 }
    variant { length s2 }
  = if length s2 > 0 then begin
      let s2' = s2[..length s2-1] in
      assert { s2 == snoc s2' s2[length s2 - 1] };
      assert { s1++s2 == snoc (s1++s2') s2[length s2 - 1] };
      occ_append k s1 s2'
    end

  lemma occ_cons :
    forall k: 'a, s: seq 'a, x: 'a.
      occ_all k (cons x s) = if k = x then 1 + occ_all k s else occ_all k s

  lemma occ_front:
    forall k: 'a, s: seq 'a.
    length s > 0 ->
    (occ_all k s[1..] =
    if k = s[0] then (occ_all k s) - 1 else occ_all k s
    ) by (s == cons s[0] s[1..])



end

(** {2 Sequences Equality} *)

module SeqEq

  use int.Int
  use Seq

  predicate seq_eq_sub (s1 s2: seq 'a) (l u: int) =
    forall i. l <= i < u -> s1[i] = s2[i]

end

module Exchange

  use int.Int
  use Seq

  predicate exchange (s1 s2: seq 'a) (i j: int) =
    length s1 = length s2 /\
    0 <= i < length s1 /\ 0 <= j < length s1 /\
    s1[i] = s2[j] /\ s1[j] = s2[i] /\
    (forall k:int. 0 <= k < length s1 -> k <> i -> k <> j -> s1[k] = s2[k])

  lemma exchange_set :
    forall s: seq 'a, i j: int.
    0 <= i < length s -> 0 <= j < length s ->
    exchange s s[i <- s[j]][j <- s[i]] i j

end

(** {2 Permutation of sequences} *)

module Permut

  use int.Int
  use Seq
  use Occ
  use SeqEq
  use export Exchange

  predicate permut (s1 s2: seq 'a) (l u: int) =
    length s1 = length s2 /\
    0 <= l <= length s1 /\ 0 <= u <= length s1 /\
    forall v: 'a. occ v s1 l u = occ v s2 l u
  (** `permut s1 s2 l u` is true when the segment `s1[l..u-1]` is a
  permutation of the segment `s2[l..u-1]`. Values outside this range are
  ignored. *)

  predicate permut_sub (s1 s2: seq 'a) (l u: int) =
    seq_eq_sub s1 s2 0 l /\
    permut s1 s2 l u /\
    seq_eq_sub s1 s2 u (length s1)
  (** `permut_sub s1 s2 l u` is true when the segment `s1[l..u-1]` is a
  permutation of the segment `s2[l..u-1]` and values outside this range
  are equal. *)

  predicate permut_all (s1 s2: seq 'a) =
    length s1 = length s2 /\ permut s1 s2 0 (length s1)
  (** `permut_all s1 s2` is true when sequence `s1` is a permutation of
  sequence `s2` *)

  let rec lemma exchange_permut_sub (s1 s2: seq 'a) (i j l u: int)
    requires { exchange s1 s2 i j }
    requires { l <= i < u }
    requires { l <= j < u }
    requires { 0 <= l <= u <= length s1 }
    ensures { permut_sub s1 s2 l u }
    variant { i }
  = if j < i then exchange_permut_sub s1 s2 j i l u
    else if i < j then begin
      assert { forall s: seq 'a, k:'a. occ k s l u =
        occ k s l i + occ k s i (i+1) + occ k s (i+1) j + occ k s j (j+1) + occ k s (j+1) u };
      assert { forall k:'a. occ k s1 l i = occ k s2 l i };
      assert { forall k:'a. occ k s1 i (i+1) = occ k s2 j (j+1) };
      assert { forall k:'a. occ k s1 (i+1) j = occ k s2 (i+1) j };
      assert { forall k:'a. occ k s1 j (j+1) = occ k s2 i (i+1) };
      assert { forall k:'a. occ k s1 (j+1) u = occ k s2 (j+1) u }
    end

  (** enlarge the interval *)
  let lemma permut_sub_weakening (s1 s2: seq 'a) (l1 u1 l2 u2: int)
    requires { permut_sub s1 s2 l1 u1 }
    requires { 0 <= l2 <= l1 }
    requires { u1 <= u2 <= length s1 }
    ensures { permut_sub s1 s2 l2 u2 }
  = if l1 <= u1 then begin
      assert { forall k:'a, s:seq 'a. occ k s l2 u2 = occ k s l2 l1 + occ k s l1 u1 + occ k s u1 u2 };
      assert { forall k:'a. occ k s1 l2 l1 = occ k s2 l2 l1 };
      assert { forall k:'a. occ k s1 u1 u2 = occ k s2 u1 u2 }
    end

  (** {3 Lemmas about permut} *)

  lemma permut_refl: forall s: seq 'a, l u: int.
    0 <= l <= length s -> 0 <= u <= length s ->
    permut s s l u

  lemma permut_sym: forall s1 s2: seq 'a, l u: int.
    permut s1 s2 l u -> permut s2 s1 l u

  lemma permut_trans:
    forall s1 s2 s3: seq 'a, l u: int.
    permut s1 s2 l u -> permut s2 s3 l u -> permut s1 s3 l u

  let lemma permut_exists (s1 s2: seq 'a) (l u i: int)
    requires { permut s1 s2 l u }
    requires { l <= i < u }
    ensures { l <= result < u }
    ensures { s1[result] = s2[i] }
  = let rec lemma aux (u: int) : int
      requires { occ s2[i] s1 l u > 0 \/
                 occ s2[i] s2 l u = occ s2[i] s1 l u /\ i < u }
      ensures { s1[result] = s2[i] }
      ensures { l <= result < u }
      variant { u - l }
    = if pure { s1[u-1] <> s2[i] } then aux (u-1)
      else u-1
    in
    aux u

  (** {3 Lemmas about permut_all} *)

  use Mem

  lemma permut_all_mem: forall s1 s2: seq 'a. permut_all s1 s2 ->
    forall x. mem x s1 <-> mem x s2

  lemma exchange_permut_all:
    forall s1 s2: seq 'a, i j: int.
    exchange s1 s2 i j -> permut_all s1 s2

end

module FoldLeft

  use Seq
  use int.Int

  (** `fold_left f a [b1; ...; bn]` is `f (... (f (f a b1) b2) ...) bn` *)
  let rec function fold_left (f: 'a -> 'b -> 'a) (acc: 'a) (s: seq 'b) : 'a
    variant { length s }
  = if length s = 0 then acc else fold_left f (f acc s[0]) s[1 ..]

  lemma fold_left_ext: forall f: 'b -> 'a -> 'b, acc: 'b, s1 s2: seq 'a.
    s1 == s2 -> fold_left f acc s1 = fold_left f acc s2

  lemma fold_left_cons: forall s: seq 'a, x: 'a, f: 'b -> 'a -> 'b, acc: 'b.
    fold_left f acc (cons x s) = fold_left f (f acc x) s

  let rec lemma fold_left_app (s1 s2: seq 'a) (f: 'b -> 'a -> 'b) (acc: 'b)
    ensures { fold_left f acc (s1 ++ s2) = fold_left f (fold_left f acc s1) s2 }
    variant { Seq.length s1 }
  = if Seq.length s1 > 0 then begin
      assert { s1 == cons s1[0] s1[1 ..] };
      fold_left_app s1[1 ..] s2 f (f acc (Seq.get s1 0))
    end

end

module FoldRight

  use Seq
  use int.Int

  (** `fold_right f [a1; ...; an] b` is `f a1 (f a2 (... (f an b) ...))` *)
  let rec function fold_right (f: 'b -> 'a -> 'a) (s: seq 'b) (acc: 'a) : 'a
    variant { length s }
  = if length s = 0 then acc
    else let acc = f s[length s - 1] acc in fold_right f s[.. length s - 1] acc

  lemma fold_right_ext: forall f: 'a -> 'b -> 'b, acc: 'b, s1 s2: seq 'a.
    s1 == s2 -> fold_right f s1 acc = fold_right f s2 acc

  lemma fold_right_snoc: forall s: seq 'a, x: 'a, f: 'a -> 'b -> 'b, acc: 'b.
    fold_right f (snoc s x) acc = fold_right f s (f x acc)

end

(*** TODO / TO DISCUSS

  - a syntax for cons and snoc?

  - create: better name? move to a separate theory?

  - UNPLEASANT: when using both arrays and sequences, the lack of overloading
    is a pain; see for instance vstte12_ring_buffer.mlw

*)
