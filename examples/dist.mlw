use int.Int

constant n : int

axiom n_pos : n >= 1


type t = { f : int -> int }
invariant { forall i. 1 <= i <= n -> 1 <= f i <= n }
invariant { forall i j. 1 <= i < j <= n -> f i <> f j }
invariant { forall k. k < 1 \/ k > n -> f k = k }
by { f = fun i -> i }

axiom t_inj : forall t1 t2. t1.f = t2.f -> t1 = t2

let function id : t = { f = fun (i : int) -> i }

let function (*) (p1 p2 : t) : t =
    let f1 = p1.f in
    let f2 = p2.f in
    { f = fun i -> f1 (f2 i) }

let rec find_pre (s : t) (i k : int)
    requires { 1 <= k <= i <= n }
    requires { forall j. j < k -> 
    ensures { s.f result = i }
    =
    if s.f k = i then 


let rec function inv (s : t) (i : int) =
    if i < 1 || i > n then i
    else find_pre s i 1


clone algebra.Group with type t = t, function op = (*), constant unit = id
