module Sec_div

  use int.Int
  use int.EuclideanDivision
  use mach.int.Int32
  use import mach.int.UInt64GMP as Limb
  use int.Power
  use ref.Ref
  use mach.c.C
  use array.Array
  use map.Map
  use types.Types
  use lemmas.Lemmas
  use sub.Sub
  use div.Div
  use logical.Logical
  use cnd.Cnd

  let sec_pi1_div_r (n:ptr limb) (nn:int32) (dp:ptr limb)
                    (dn:int32) (dinv:limb) (tp:ptr limb) : unit
    requires { valid n nn /\ valid dp dn }
    requires { valid tp (dn + 1) }
    requires { normalized dp dn }
    requires { if (pelts dp)[offset dp + dn-1] = radix - 1
               then reciprocal dinv ((pelts dp)[offset dp + dn-1])
               else reciprocal dinv ((pelts dp)[offset dp + dn-1] + 1) }
    requires { 1 <= dn <= nn }
    ensures  { value n dn = mod (old value n nn) (value dp dn) }
    writes   { n.data.elts, tp.data.elts }
  =
    let ghost vn = value n (int32'int nn) in
    if nn = dn
    then begin
      (* TODO sub_n_rx *)
      let cy = wmpn_sub_in_place n dn dp dn in
      let ghost _c = wmpn_cnd_add_n_in_place cy n dp dn in
      assert { _c = 0 };
      return;
    end;
    (* computing the quotient simplifies the proof: do it in ghost code *)
    let ghost ref vq:int = 0 in
    let ghost vd = value dp (int32'int dn) in
    let ref hp = C.incr tp 0 in
    assert { valid hp (dn+1) };
    let ghost gamma : int = power 2 32 in
    assert { gamma * gamma = radix };
    set_ofs hp dn (wmpn_lshift hp dp dn 32);
    value_tail hp dn;
    assert { value hp (dn+1) = value dp dn * gamma };
    let ref np = C.incr n (nn - dn) in
    let ref nh:limb = 0 in
    value_tail dp (dn - 1);
    assert { 2 * vd >= power radix dn
             by normalized dp dn
             so 2 * (pelts dp)[offset dp + dn - 1] >= radix
             so 2 * vd
                = 2 * (value dp (dn - 1)
                       + power radix (dn - 1) * (pelts dp)[offset dp + dn - 1])
                >= power radix (dn - 1) * 2 * (pelts dp)[offset dp + dn - 1]
                >= power radix (dn - 1) * radix = power radix dn };
    (*let ghost d = (pelts dp)[dn-1] in*)
    for i = nn - dn - 1 downto 0 do
      invariant { i < nn - dn }
      invariant { offset np = offset n + i + 1 }
      invariant { plength hp = plength tp }
      invariant { plength np = plength n }
      invariant { min np = min n /\ max np = max n }
      invariant { min hp = min tp /\ max hp = max tp }
      invariant { pelts np = pelts n }
      invariant { vn = vq * vd
                  + value n (dn + i + 1) + power radix (dn + i + 1) * nh }
      invariant { (* vd *) 0 <= value np dn + power radix dn * nh < 4 * vd
                  \/ (nh = 0 /\ vq = 0) }
      invariant { 0 <= nh <= 1 }
      label StartLoop in
      np <- C.incr np (-1);
      assert { radix * vd <= value np (dn+1) + power radix (dn+1) * nh
               < 4 * radix * vd
               \/ (nh = 0 /\ vq = 0) };
      let ndn = get_ofs np dn in
      nh <- lsl nh 32 + lsr_mod ndn 32;
      let (ghost _d1, q1h) = mul_double nh dinv in
      let q1h =  q1h + nh in
      assert { radix * q1h <= nh * (radix + dinv) < radix * (q1h + 1) };
      vq <- vq + gamma * power radix (int32'int i) * uint64'int q1h;
      let ghost _b1 = wmpn_submul_1 np hp (dn+1) q1h in
      assert { _b1 = nh at StartLoop }; (*?*)
      assert { gamma * vd <= value np dn < 4 * gamma * vd
                  \/ (nh = 0 /\ vq = 0) };
      assert { 0 <= nh <= 3 };
      nh <- get_ofs np dn;
      let (ghost _d0, q0h) = mul_double nh dinv in
      let q0h = q0h + nh in
      vq <- vq + power radix (int32'int i) * uint64'int q0h;
      nh <- nh - wmpn_submul_1 np dp dn q0h;
    done;
    assert { offset np = offset n };
    assert { vn = vq * vd + value np dn + power radix dn * nh };
    begin
      ensures { vn = vq * vd + value n dn + power radix dn * nh }
      ensures { value np dn + power radix dn * nh < 3 * vd (* ??? *) }
      ensures { 0 <= nh <= 1 }
      label Adj1 in
      let cnd = if nh <> 0 then 1 else 0 in
      vq <- vq + uint64'int cnd;
      assert { cnd = 0 -> value np dn + power radix dn * nh < 3 * vd
               by nh = 0
               so value np dn + power radix dn * nh
                  < power radix dn
                  <= 2 * vd };
      nh <- nh - wmpn_cnd_sub_n_in_place cnd np dp dn;
      assert { cnd = 1 ->
               (vq * vd + value np dn + power radix dn * nh = vn
               /\ value np dn + power radix dn * nh < 3 * vd)
               by value np dn + power radix dn * nh
                   = (value np dn + power radix dn * nh at Adj1) - vd
                   < 4 * vd - vd = 3 * vd
               so vq = (vq at Adj1) + 1
               so value n dn = value np dn };
    end;
    begin
      ensures { vn = vq * vd + value n dn }
      ensures { value np dn < 2 * vd }
      (* TODO sub_n_rx *)
      let ref cy = wmpn_sub_in_place np dn dp dn in
      assert { nh = 1 -> cy = 1 };
      cy <- cy - nh;
      assert { 0 <= cy <= 1 };
      vq <- vq + uint64'int (1 - cy);
      let ghost _c = wmpn_cnd_add_n_in_place cy np dp dn in
      assert { _c = 0 };
    end;
    begin
      ensures { if old value np dn >= vd
                then value np dn = value np dn - vd /\ vq = old vq + 1
                else value np dn = old value np dn /\ vq = old vq }
      ensures { vn = vq * vd + value n dn }
      ensures { value np dn < vd }
      (* TODO sub_n_rx *)
      let cy = wmpn_sub_in_place np dn dp dn in
      vq <- vq + uint64'int (1 - cy);
      let ghost _c = wmpn_cnd_add_n_in_place cy np dp dn in
      assert { _c = 0 };
    end;
    return

  let wmpn_sec_div_r (np: ptr limb) (nn: int32) (dp: ptr limb) (dn: int32)
                (tp: ptr limb) : unit
    requires { 1 <= dn <= nn < power 2 31 }
    requires { valid np nn }
    requires { valid dp dn }
    requires { valid tp (nn + 2 * dn + 2) }
    requires { (pelts dp)[offset dp + (dn-1)] > 0 }
    ensures  { value np dn = mod (old value np nn) (value dp dn) }
    ensures  { min tp = old min tp /\ max tp = old max tp
               /\ plength tp = old plength tp }
  =
    label Start in
    let d1 = get_ofs dp (dn - 1) in
    let cnt = of_int32 (count_leading_zeros d1) in
    let ghost vn = value np (int32'int nn) in
    if cnt <> 0
    then begin
      let tp2 = incr_split tp (nn + dn + 1) in
      let np2 = incr_split tp dn in
      let dp2 = tp in
      value_tail dp (dn - 1);
      let ghost _c = wmpn_lshift dp2 dp dn cnt in
      assert { _c = 0
               by value dp dn = value dp (dn - 1) + power radix (dn - 1) * d1
               so d1 * power 2 cnt < radix
               so let tnc = Limb.length - cnt in
                  power 2 tnc * power 2 cnt = power 2 (tnc + cnt) = radix
               so d1 * power 2 cnt < power 2 tnc * power 2 cnt
               so d1 < power 2 tnc
               so (d1 + 1) * power 2 cnt <= power 2 tnc * power 2 cnt = radix
               so value dp (dn - 1) < power radix (dn - 1)
               so value dp dn < power radix (dn - 1) + power radix (dn - 1) * d1
                  = power radix (dn - 1) * (d1 + 1)
               so value dp dn * power 2 cnt
                  < power radix (dn - 1) * ((d1 + 1) * power 2 cnt)
                  <= power radix (dn - 1) * radix = power radix dn
               so power radix dn * _c <= value dp2 dn + power radix dn * _c
                  < power radix dn
               so _c < 1 };
      let cy = wmpn_lshift np2 np nn cnt in
      value_sub_update_no_change (pelts np2) (offset np2 + int32'int nn)
                                 (offset np2) (offset np2 + int32'int nn) cy;
      C.set_ofs np2 nn cy;
      value_tail np2 nn;
      assert { value np2 (nn+1) = vn * power 2 cnt };
      let ref nn = nn + 1 in
      let ghost vn2 = value np2 (int32'int nn) in
      let ref d0 = get_ofs dp2 (dn - 1) in
      value_tail dp2 (dn - 1);
      assert { d0 >= div radix 2
               by 2 * power 2 cnt * d1 >= radix
               so value dp dn >= d1 * power radix (dn - 1)
               so power radix dn = power radix (dn - 1) * radix
                  <= power radix (dn - 1) * (2 * power 2 cnt * d1)
                  <= (2 * power 2 cnt) * value dp dn
               so value dp2 dn = value dp dn * power 2 cnt
               so 2 * value dp2 dn >= power radix dn
               so value dp2 dn
                  = value dp2 (dn - 1) + power radix (dn - 1) * d0
                  < power radix (dn - 1) + power radix (dn - 1) * d0
                  = power radix (dn - 1) * (d0 + 1)
               so 2 * power radix (dn - 1) * (d0 + 1)
                  > power radix dn
               so 2 * (d0 + 1) > radix
               so d0 + 1 > div radix 2 };
      begin ensures { (pelts dp2)[offset dp2 + dn-1] = radix - 1
                      -> d0 = (pelts dp2)[offset dp2 + dn-1] }
            ensures { (pelts dp2)[offset dp2 + dn-1] <> radix - 1
                      -> d0 = (pelts dp2)[offset dp2 + dn-1] + 1 }
        d0 <- d0 + of_bool (bnot d0 <> 0);
      end;
      let inv32 = invert_limb d0 in
      sec_pi1_div_r np2 nn dp2 dn inv32 tp2;
      assert { value dp2 dn > 0 by d0 > 0 };
      let ghost q = div vn2 (value dp2 (int32'int dn)) in
      assert { vn2 = q * value dp2 dn + value np2 dn };
      let ghost _c = wmpn_rshift np np2 dn cnt in
      let ghost vd = value dp (int32'int dn) in
      assert { _c = 0 /\ value np dn = mod vn vd
               by vn2 = power 2 cnt * vn
                  = q * power 2 cnt * vd + value np2 dn
               so value np2 dn = power 2 cnt * (vn - q * vd)
               so let tnc = Limb.length - cnt in
                  power 2 tnc * power 2 cnt = radix
               so _c + radix * value np dn
                  = value np2 dn * power 2 tnc
                  = power 2 tnc * power 2 cnt * (vn - q * vd)
                  = radix * (vn - q * vd)
               so _c = radix * (vn - q * vd - value np dn)
               so 0 <= _c < radix
               so _c = 0
               so radix * value np dn = radix * (vn - q * vd)
               so value np dn = vn - q * vd
               so value np2 dn < value dp2 dn
               so value np dn * power 2 cnt = value np2 dn
               so vd * power 2 cnt = value dp2 dn
               so 0 <= value np dn < vd
               so mod vn vd
                  = mod (vd * (-q) + vn) vd
                  = mod (value np dn) vd
                  = value np dn };
      join dp2 np2;
      join dp2 tp2
    end
    else begin
      let ref d0 = get_ofs dp (dn - 1) in
      begin ensures { if (old d0) = radix - 1
                      then d0 = old d0
                      else d0 = old d0 + 1 }
        d0 <- d0 + of_bool (bnot d0 <> 0);
      end;
      let inv32 = invert_limb d0 in
      sec_pi1_div_r np nn dp dn inv32 tp
    end

end