
(* Selection sort. *)

module SelectionSort

  use int.Int
  use ref.Ref
  use array.Array
  use array.ArraySwap
  use seq.SortedInt
  use seq.Permut

  let selection_sort (a: array int) : (ghost p: permutation)
    ensures { sorted_all a /\ permut_all (old a) a p } =
    let ref min = 0 in
    let ghost ref p = identity a.length in
    for i = 0 to length a - 1 do
      (* a[0..i[ is sorted; now find minimum of a[i..n[ *)
      invariant { sorted a 0 i }
      invariant { permut_all (old a) a p }
      invariant { forall k1 k2. 0 <= k1 < i <= k2 < length a -> a[k1] <= a[k2] }
      (* let min = ref i in *) min := i;
      for j = i + 1 to length a - 1 do
        invariant { i <= min < j }
        invariant { forall k. i <= k < j -> a[min] <= a[k] }
        if a[j] < a[min] then min := j
      done;
      label L in
      if min <> i then p := swap a min i p;
    done;
    p

  let test1 () =
    let a = make 3 0 in
    a[0] <- 7; a[1] <- 3; a[2] <- 1;
    let _ = selection_sort a in
    a

  let test2 () ensures { result.length = 8 } =
    let a = make 8 0 in
    a[0] <- 53; a[1] <- 91; a[2] <- 17; a[3] <- -5;
    a[4] <- 413; a[5] <- 42; a[6] <- 69; a[7] <- 6;
    let _ = selection_sort a in
    a

  exception BenchFailure

  let bench () raises { BenchFailure -> true } =
    let a = test2 () in
    if a[0] <> -5 then raise BenchFailure;
    if a[1] <> 6 then raise BenchFailure;
    if a[2] <> 17 then raise BenchFailure;
    if a[3] <> 42 then raise BenchFailure;
    if a[4] <> 53 then raise BenchFailure;
    if a[5] <> 69 then raise BenchFailure;
    if a[6] <> 91 then raise BenchFailure;
    if a[7] <> 413 then raise BenchFailure;
    a

end
